<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Squirrel Wars</title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>


    <script src="https://sad.adsgram.ai/js/sad.min.js"></script>

    <style>
        /* Обнуление и базовые стили */
        body, html {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a1a;
            color: white;
            overflow: hidden; 
            /* НОВОЕ: Запрет нежелательной прокрутки на мобильных */
            overscroll-behavior-y: none; 
        }

        #root {
            height: 100vh;
            /* НОВОЕ: Fix для корректной высоты на iOS/мобильных */
            min-height: -webkit-fill-available; 
            min-height: 100dvh; 
        }

        /* Контейнер всей игры */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            min-height: -webkit-fill-available; 
            min-height: 100dvh;
            width: 100%;
            margin: 0 auto;
            background-color: #222;
            background-image: url('images/bg_forest_main.png');
            background-size: cover;
            background-position: center;
        }

        /* 1. Хедер (Шапка) */
        .header {
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: none; 
            border-bottom: none; 
            flex-shrink: 0;
        }
        
        .header-user {
            display: flex;
            align-items: center;
            font-weight: bold;
            font-size: 1.1em;
            background: rgba(0, 0, 0, 0.6); 
            padding: 8px 18px; 
            border-radius: 25px; 
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); 
            gap: 8px;
        }
        .header-user img {
            width: 40px; 
            height: 40px;
            border-radius: 50%;
            border: 2px solid gold; 
            flex-shrink: 0;
        }
        
        .header-balance {
            font-size: 1.4em; 
            font-weight: bold;
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.6); 
            padding: 8px 18px; 
            border-radius: 25px; 
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); 
            gap: 8px; 
        }
        .header-balance img {
            width: 40px; 
            height: 40px;
            object-fit: contain; 
            border-radius: 50%; 
            border: 2px solid rgba(255, 215, 0, 0.7); 
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.5); 
            flex-shrink: 0; 
        }

        /* --- АДАПТАЦИЯ ХЕДЕРА И ЕГО ЭЛЕМЕНТОВ --- */
        .header {
            padding: 8px 10px; /* Уменьшаем горизонтальный padding */
        }
        .header-user {
            font-size: 1em; /* Чуть уменьшаем шрифт */
            padding: 6px 14px;
            gap: 6px;
        }
        .header-user img {
            width: 35px; 
            height: 35px;
        }
        .header-balance {
            font-size: 1.2em; /* Чуть уменьшаем шрифт */
            padding: 6px 14px;
            gap: 6px;
        }
        .header-balance img {
            width: 35px; 
            height: 35px;
        }
        /* --- КОНЕЦ АДАПТАЦИИ ХЕДЕРА --- */

        /* 2. Игровой экран (меняется) */
        .game-screen {
            flex-grow: 1;
            padding: 0; 
            overflow: hidden; 
            position: relative; 
        }
        
        .boost-header {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px 0;
            background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.2));
            border-radius: 10px;
            border-bottom: 3px solid gold;
        }
        .boost-header h2 {
            margin: 0;
            /* Используем 1.5em, чтобы быть уверенными, что поместится */
            font-size: 1.5em; 
            color: gold;
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.8), 0 0 10px rgba(255, 215, 0, 0.5);
            font-weight: 900;
            letter-spacing: 1px;
            /* Удалены white-space: nowrap и overflow: hidden */
        }

        .golden-nut-container {
            position: absolute;
            width: 60px; 
            height: 60px;
            cursor: pointer;
            z-index: 50;
            filter: drop-shadow(0 0 8px gold);
            transition: top 1s ease-in-out, left 1s ease-in-out, opacity 0.3s; 
        }
        .golden-nut-container img {
            width: 100%;
            height: 100%;
            animation: floatBob 1.5s infinite alternate ease-in-out;
        }
        
        @keyframes floatBob {
            0% { transform: translateY(0) rotate(0deg); }
            100% { transform: translateY(-5px) rotate(2deg); }
        }
        
        /* === ОБНОВЛЕННЫЕ СТИЛИ ДЛЯ ИНДИКАТОРА БОНУСОВ === */
        .active-bonus-indicator {
            position: absolute;
            /* Смещаем вниз, чтобы не закрывать кнопки Настроек и Заданий */
            top: 15px; 
            left: 50%;
            /* Сдвигаем влево на 50% и обратно на 50% его собственной ширины для центрирования */
            transform: translateX(-50%); 
            
            display: flex; 
            flex-direction: column; 
            gap: 3px; /* Уменьшаем вертикальный отступ между плашками */
            
            /* Устанавливаем максимальную ширину, чтобы он не заходил на кнопки */
            max-width: 60%; 
            
            z-index: 60;
        }

        /* Стиль для каждой отдельной плашки бонуса */
        .bonus-indicator-item {
            display: flex;
            flex-direction: row; 
            align-items: center;
            white-space: nowrap; 
            margin: 0;
            
            /* Уменьшаем padding для компактности */
            padding: 3px 8px; 
            background: rgba(255, 215, 0, 0.9);
            color: black;
            font-weight: bold;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
            text-align: center;
            animation: flash 0.5s infinite alternate; 
            /* КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: Уменьшаем размер шрифта */
            font-size: 0.9em; 
        }
        
        .bonus-indicator-subtext {
             /* Убираем старые стили, они не нужны */
        }
        /* === КОНЕЦ ОБНОВЛЕННЫХ СТИЛЕЙ === */
        
        @keyframes flash {
            from { opacity: 1; }
            to { opacity: 0.8; }
        }
        
        .locked-screen-message {
            display: flex;
            flex-direction: column;
            justify-content: center; 
            align-items: center; 
            height: 100%;
            width: 100%;
            background: rgba(0, 0, 0, 0.9); 
            color: #FFD700; 
            font-size: 1.3em;
            font-weight: bold;
            padding: 20px;
            box-sizing: border-box; 
        }
        .locked-screen-message h3 {
             text-align: center; 
        }
        .locked-screen-message p {
            color: #eee; 
            font-size: 1em; 
            margin-top: 15px; 
            text-align: center; 
            max-width: 90%; 
        }


        .forest-content {
            position: relative;
            display: flex;
            flex-direction: column; 
            justify-content: center; 
            align-items: center;
            height: 100%;
            
            /* --- КРИТИЧЕСКОЕ ИСПРАВЛЕНИЕ: Включаем Мультитач --- */
            touch-action: manipulation; 
            /* -------------------------------------------------- */
        }

        .forest-screen .squirrel-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            transition: transform 0.05s ease;
            position: relative;
            z-index: 10;
            /* --- ИСПРАВЛЕНИЕ: Убираем синюю обводку при фокусе/клике --- */
            outline: none; 
            -webkit-tap-highlight-color: transparent; 
            user-select: none;
            /* ----------------------------------------------------- */
        }
        
        @keyframes clickShake {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        /* ЗАМЕНА: Теперь анимация управляется классом .is-active из JS */
        .forest-screen .squirrel-btn.is-active {
            animation: clickShake 0.15s ease-out; 
            transform: scale(0.98); 
        }

        .forest-screen .squirrel-btn img {
            width: 100%; 
            max-width: 400px; 
            height: auto; 
            position: relative;
            top: 20px; 
            pointer-events: none;
        }
        
        .forest-screen h3 {
            display: none; 
        }

        .tap-animation {
            position: absolute;
            top: 50%; 
            left: 50%;
            font-size: 2em;
            font-weight: 900;
            color: gold;
            text-shadow: 1px 1px 3px black;
            pointer-events: none;
            opacity: 0;
            animation: floatUp 1s ease-out forwards;
            z-index: 20;
        }

        @keyframes floatUp {
            0% { opacity: 0; transform: translate(-50%, 0); }
            15% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -150px); }
        }
        
        @keyframes floatUpCrit {
            0% { opacity: 0; transform: translate(-50%, 0) scale(1); }
            15% { opacity: 1; transform: translate(-52%, -5px) scale(1.2) rotate(-5deg); }
            30% { opacity: 1; transform: translate(-48%, -10px) scale(1.2) rotate(5deg); }
            100% { opacity: 0; transform: translate(-50%, -150px) scale(1.2) rotate(0deg); }
        }
        
        .tap-animation.critical {
            font-size: 3em; 
            color: #FFA500; 
            text-shadow: 0 0 5px black, 0 0 10px #FFD700;
            animation: floatUpCrit 1s ease-out forwards; 
        }


        .game-screen-scroll {
             padding: 20px;
             overflow-y: auto;
             height: 100%;
        }
        .upgrade-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-bottom: 50px;
            padding-top: 10px; /* НОВОЕ: Отступ сверху */
            padding-left: 10px; /* НОВОЕ: Отступ слева */
            padding-right: 10px; /* НОВОЕ: Отступ справа */
        }
        .upgrade-item {
            display: flex;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px; /* УМЕНЬШЕНО с 10px */
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .upgrade-item img {
            width: 40px; /* УМЕНЬШЕНО с 48px */
            height: 40px; /* УМЕНЬШЕНО с 48px */
            margin-right: 10px; /* УМЕНЬШЕНО с 15px */
            background: #444; 
            border-radius: 8px;
        }
        
        .upgrade-info {
            flex-grow: 1;
            text-align: left;
        }
        .upgrade-info strong {
            margin-bottom: 2px; /* УМЕНЬШЕНО с 4px */
            display: inline-block;
            font-size: 0.95em; /* НОВОЕ: Чуть меньше шрифт */
        }
        .upgrade-info .level-text {
            font-size: 0.85em; /* УМЕНЬШЕНО с 0.9em */
            color: #aaa; 
            margin-bottom: 2px; /* УМЕНЬШЕНО с 4px */
        }
        .upgrade-info .description-line {
            font-size: 0.85em;
            color: #eee; 
            font-weight: 500;
            line-height: 1.3;
            word-break: break-all;
        }
        .upgrade-info .description-line-next {
            color: #4CAF50; 
            font-weight: bold;
        }
        
        .buy-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 8px 10px; 
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            flex-shrink: 0;
            transition: background-color 0.3s;
            font-size: 0.9em; 
            line-height: 1.1;
            /* --- НОВОЕ: Стили для объемности --- */
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.4), 0 0 15px rgba(0, 0, 0, 0.2); 
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); 
            border-bottom: 2px solid rgba(0, 0, 0, 0.3); /* Имитация глубины */
            /* ------------------------------------- */
        }
        .buy-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
            animation: none; 
        }
        .buy-btn:active {
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.4), 0 0 10px rgba(0, 0, 0, 0.2); 
            transform: translateY(2px);
            border-bottom: 0;
        }
        .buy-btn.purchased { 
            background-color: #3F51B5; 
        }
        .buy-btn.max-level {
            background-color: #CC0000;
            cursor: not-allowed;
        }
        /* Добавим стили для кнопок Вложить/Забрать в VaultControls */
        .vault-controls-btn-container {
             display: flex;
             gap: 20px; /* Увеличиваем отступ, как на референсе */
             justify-content: center;
             margin-bottom: 15px;
        }

        .vault-controls .buy-btn {
            min-width: 120px; /* Фиксируем ширину для лучшего вида */
            padding: 12px 20px; /* Увеличиваем padding */
            font-size: 1.1em;
            font-weight: 800;
        }
        
        .raid-content { display: flex; flex-direction: column; align-items: center; text-align: center; padding-top: 20px; }
        .raid-btn { background-color: #E53935; color: white; border: none; padding: 20px 30px; border-radius: 12px; font-size: 1.2em; font-weight: bold; cursor: pointer; margin-top: 20px; }
        .raid-log { margin-top: 30px; text-align: left; font-size: 0.9em; color: #ccc; width: 100%; padding: 0 20px; box-sizing: border-box; }
        .raid-battle-container { flex-grow: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; padding: 20px; box-sizing: border-box; }
        .defender-info { margin-bottom: 20px; }
        .raid-hp-bar { width: 100%; max-width: 300px; height: 20px; background-color: rgba(255, 255, 255, 0.2); border-radius: 10px; overflow: hidden; margin-bottom: 10px; }
        .raid-hp-fill { height: 100%; background: linear-gradient(90deg, #E53935, #FFB300); transition: width 0.1s linear; }
        .raid-duplo-btn { background: none; border: none; padding: 0; cursor: pointer; transition: transform 0.05s ease; }
        .raid-duplo-btn img { width: 200px; height: auto; }
        .raid-result { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 30px; background: rgba(0, 0, 0, 0.8); border-radius: 15px; z-index: 100; text-align: center; }
        .energy-bar-container { padding: 10px 15px; flex-shrink: 0; background: rgba(0, 0, 0, 0.3); }
        .energy-bar-label { display: flex; justify-content: space-between; font-size: 0.9em; margin-bottom: 5px; }
        .energy-bar-fill { width: 100%; height: 10px; background-color: rgba(255, 255, 255, 0.2); border-radius: 5px; overflow: hidden; }
        .energy-bar-inner { height: 100%; background: linear-gradient(90deg, #64DD17, #33B760); border-radius: 5px; transition: width 0.5s ease; }
        .tab-bar { display: flex; justify-content: space-around; background: rgba(0, 0, 0, 0.9); border-top: 1px solid rgba(255, 255, 255, 0.1); flex-shrink: 0; padding: 0 0 0 0; /* УБРАН нижний padding */ }
        .tab-item { 
            flex-grow: 1; 
            /* ИЗМЕНЕНО: Увеличиваем отступы сверху и снизу с 5px до 8px. 
               Это сделает весь таб-бар выше.
            */
            padding: 8px 2px 8px 2px; 
            text-align: center; 
            cursor: pointer; 
            color: #eee; 
            border-top: 3px solid transparent; 
            transition: color 0.2s, border-color 0.2s, transform 0.1s; 
            /* ИЗМЕНЕНО: Слегка вернем размер шрифта, чтобы он соответствовал */
            font-size: 0.95em; 
            font-weight: 500; 
        }
        .tab-item:active { transform: scale(0.98); }
        .tab-item img {
            /* ИЗМЕНЕНО: Увеличиваем иконки */
            width: 40px; 
            height: 40px; 
            opacity: 0.9;
            margin-bottom: 2px;
            display: block;
            margin: 0 auto 2px auto;
        }
        .tab-item.active { color: #eee; border-top-color: #FFD700; }
        .tab-item.active img { opacity: 1; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .app-modal { background: #282828; padding: 20px; /* УМЕНЬШЕНО с 30px */ border-radius: 15px; max-width: 95%; /* УВЕЛИЧЕНО с 300px/90% */ width: auto; text-align: center; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); border: 2px solid gold; animation: fadeIn 0.3s ease-out; box-sizing: border-box; }
        .app-modal h3 { font-size: 1.3em; /* УМЕНЬШЕНО с 1.5em */ margin-top: 0; margin-bottom: 15px; font-weight: bold; }
        .app-modal h3.success { color: #4CAF50; }
        .app-modal h3.max-level { color: #FFD700; text-shadow: 0 0 5px rgba(255, 215, 0, 0.8); }
        .app-modal h3.ended { color: #FF7043; }
        .app-modal p { color: white; font-size: 1em; /* УМЕНЬШЕНО с 1.1em */ margin-bottom: 20px; line-height: 1.4; }
        .app-modal .icon { font-size: 3em; margin-bottom: 15px; display: inline-block; }
        .app-modal .bot-icon { animation: pulse 1.5s infinite alternate; }
        .app-modal .level-icon { color: gold; text-shadow: 0 0 10px rgba(255, 215, 0, 0.8); }
        .app-modal .buy-btn { background-color: #4CAF50; color: white; font-weight: bold; padding: 10px 20px; border-radius: 8px; border: none; cursor: pointer; transition: background-color 0.2s; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.05); } }
        @keyframes pulse-green { 0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); } 70% { box-shadow: 0 0 10px 10px rgba(76, 175, 80, 0); } 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); } }
        
        /* СТИЛИ ДЛЯ КНОПОК НА ОСНОВЕ ИЗОБРАЖЕНИЯ (Task, Daily) */
        .tasks-button, .daily-rewards-button { 
            position: absolute; 
            width: 55px; /* УМЕНЬШЕНО с 65px */
            height: 55px; /* УМЕНЬШЕНО с 65px */
            background: none; border: none; border-radius: 0; 
            display: flex; 
            justify-content: center; align-items: center; 
            cursor: pointer; z-index: 40; 
            padding: 0; 
            color: transparent; 
            text-shadow: none; 
        }

        /* СТИЛЬ ТОЛЬКО ДЛЯ КНОПКИ НАСТРОЕК (Уменьшенный размер) */
        .settings-button { 
            position: absolute; 
            width: 45px; /* УМЕНЬШЕНО с 55px */
            height: 45px; /* УМЕНЬШЕНО с 55px */
            background: none; border: none; border-radius: 0; 
            display: flex; 
            justify-content: center; align-items: center; 
            cursor: pointer; z-index: 40; 
            padding: 0; 
            color: transparent; 
            text-shadow: none; 
        }

        /* СТИЛЬ ТОЛЬКО ДЛЯ КНОПКИ НАСТРОЕК (Уменьшенный размер) */
        .settings-button { 
            position: absolute; 
            width: 45px; 
            height: 45px; 
            /* ... старые стили ... */
        }

        /* --- ДОБАВИТЬ ВОТ ЭТОТ БЛОК --- */
        .ads-button {
            position: absolute;
            top: 75px; /* Отступ сверху, чтобы быть под кнопкой настроек */
            left: 15px; /* Слева, как и настройки */
            width: 45px;
            height: 45px;
            background: none; 
            border: none; 
            border-radius: 0;
            display: flex;
            justify-content: center; 
            align-items: center;
            cursor: pointer; 
            z-index: 40;
            padding: 0;
            color: transparent;
            text-shadow: none;
            transition: transform 0.1s;
        }
        .ads-button:active {
            transform: scale(0.95);
        }
        .ads-button img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        /* --- КОНЕЦ НОВОГО БЛОКА --- */

        /* НОВЫЕ ПОЗИЦИИ (ближе к краю) */

        /* НОВЫЕ ПОЗИЦИИ (ближе к краю) */
        .tasks-button { top: 15px; right: 15px; } 
        .daily-rewards-button { top: 75px; right: 15px; } /* Сдвинуто ближе */
        .settings-button { top: 15px; left: 15px; right: auto; }

        .tasks-button img, .daily-rewards-button img, .settings-button img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.2s;
        }

        .settings-button:active img, .daily-rewards-button:active img, .tasks-button:active img { 
            transform: scale(0.95); 
        }
         
        .notification-badge { position: absolute; top: 0px; right: 0px; background: red; color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 0.6em; font-weight: bold; }
        .daily-rewards-button .notification-badge { top: 5px; right: 5px; }
        .tasks-modal { background: #282828; padding: 15px; /* УМЕНЬШЕНО */ border-radius: 15px; max-width: 95%; /* УВЕЛИЧЕНО */ width: auto; text-align: center; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); border: 2px solid gold; animation: fadeIn 0.3s ease-out; box-sizing: border-box; max-height: 90vh; display: flex; flex-direction: column; }
        .tasks-modal h2 { color: gold; margin-top: 0; display: flex; justify-content: center; align-items: center; position: relative; margin-bottom: 15px; }
        /* Контейнер для прокрутки заданий/наград внутри модальных окон */
        .task-list-content, .daily-rewards-content {
            flex-grow: 1; /* Позволяет контейнеру занимать все доступное место */
            overflow-y: auto; /* Включает прокрутку только внутри этого блока */
            padding-top: 10px; /* Небольшой отступ сверху */
        }
        /* Стиль для прокручиваемой области наград */
        .daily-rewards-content {
            flex-grow: 1; /* Позволяет блоку заполнить всю высоту */
            overflow-y: auto; /* Включает прокрутку, если контент не помещается */
            padding: 10px 0; /* Отступы для прокручиваемой области */
            /* Устанавливаем минимальную высоту, чтобы гарантировать видимость */
            min-height: 150px; 
            
            /* Убедитесь, что ваш .task-list-content и .daily-rewards-content */
            /* имеют одинаковые стили для прокрутки, если они были ранее разделены */
        }
        .task-tab-bar { display: flex; justify-content: space-around; border-bottom: 1px solid #555; margin-bottom: 15px; }
        .task-tab { flex-grow: 1; padding: 10px 5px; cursor: pointer; color: #aaa; font-weight: 500; border-bottom: 3px solid transparent; transition: color 0.2s, border-color 0.2s; position: relative; }
        .task-tab:hover { color: #eee; }
        .task-tab.active { color: gold; border-bottom-color: gold; }
        .task-tab-badge { position: absolute; top: 5px; right: 5px; background: red; color: white; width: 18px; height: 18px; border-radius: 50%; display: flex; justify-content: center; align-items: center; font-size: 0.7em; font-weight: bold; line-height: 18px; }
        .task-list-content { max-height: calc(90vh - 200px); overflow-y: auto; &::-webkit-scrollbar { width: 6px; } &::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; } &::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); } }
        .task-item { display: flex; align-items: center; background: rgba(0, 0, 0, 0.3); padding: 10px; border-radius: 10px; margin-bottom: 10px; border: 1px solid rgba(255, 255, 255, 0.1); transition: background 0.3s, border-color 0.3s; }
        .task-item.is-claimable { background: rgba(76, 175, 80, 0.15); border-color: #4CAF50; }
        .task-item.is-claimable .buy-btn { background-color: #4CAF50; animation: pulse-green 1.5s infinite; }
        .task-item .icon { font-size: 2em; margin-right: 15px; }
        .task-info { flex-grow: 1; text-align: left; }
        .task-title-row { display: flex; align-items: center; gap: 8px; }
        .task-info-btn { background: #555; color: white; border: 1px solid #777; border-radius: 50%; width: 20px; height: 20px; font-size: 0.8em; font-weight: bold; padding: 0; cursor: pointer; line-height: 18px; flex-shrink: 0; }
        .task-info strong { font-size: 1.1em; }
        .task-info .progress-text { font-size: 0.9em; color: #aaa;word-break:break-all; }
        .progress-bar { width: 100%; height: 8px; background: rgba(255, 255, 255, 0.1); border-radius: 4px; margin-top: 5px; overflow: hidden; }
        .progress-bar-inner { height: 100%; background: #4CAF50; border-radius: 4px; transition: width 0.3s; }
        .daily-rewards-modal { 
            background: #282828; padding: 15px; border-radius: 15px; max-width: 95%; width: auto; 
            text-align: center; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); border: 2px solid gold; 
            animation: fadeIn 0.3s ease-out; box-sizing: border-box; 
            /* --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: Задаем структуру для компоновки --- */
            max-height: 90vh; 
            display: flex; 
            flex-direction: column;
            
        }
         .daily-rewards-modal h2 { color: gold; margin-top: 0; margin-bottom: 20px; }
        .daily-rewards-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
        .daily-reward-item { background: rgba(0, 0, 0, 0.3); border: 2px solid #555; border-radius: 10px; padding: 15px 10px; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100px; box-sizing: border-box; }
        .daily-reward-item .day-label { font-size: 0.9em; font-weight: bold; color: #aaa; margin-bottom: 10px; }
        .daily-reward-item .reward-icon { font-size: 2em; margin-bottom: 10px; }
        .daily-reward-item .reward-label { font-size: 1em; font-weight: bold; }
        .daily-reward-item.day-7 { grid-column: span 3; background: linear-gradient(145deg, rgba(0, 0, 0, 0.3), rgba(255, 215, 0, 0.1)); border-color: #777; }
        .daily-reward-item.locked { background: rgba(0, 0, 0, 0.6); border-color: #444; color: #777; cursor: pointer; }
         .daily-reward-item.locked .reward-icon { font-size: 2.5em; }
        .daily-reward-item.claimed { background: rgba(0, 0, 0, 0.1); border-color: #4CAF50; opacity: 0.6; }
        .daily-reward-item.claimed .reward-icon { font-size: 2.5em; color: #4CAF50; }
        .daily-reward-item.available { background: rgba(76, 175, 80, 0.15); border-color: #4CAF50; color: #fff; cursor: pointer; animation: pulse-green 1.5s infinite; transition: transform 0.2s ease; }
        .daily-reward-item.available:hover { transform: scale(1.05); }
        .settings-modal { background: #282828; padding: 20px; border-radius: 15px; max-width: 400px; width: 90%; text-align: left; box-shadow: 0 0 30px rgba(255, 215, 0, 0.5); border: 2px solid gold; animation: fadeIn 0.3s ease-out; box-sizing: border-box; max-height: 90vh; overflow-y: auto; }
        .settings-modal h2 { color: gold; margin-top: 0; margin-bottom: 25px; text-align: center; }
        .settings-section { margin-bottom: 20px; }
        .settings-section h3 { margin-top: 0; margin-bottom: 10px; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .settings-section p { font-size: 0.95em; color: #ccc; line-height: 1.5; margin: 0; }
        .settings-toggle-row { display: flex; justify-content: space-between; align-items: center; font-size: 1.1em; font-weight: bold; padding: 10px 0; }
        .settings-toggle-row input[type="range"] { flex-grow: 1; margin-left: 15px; margin-right: 10px; cursor: pointer; }
        .settings-toggle-row span { min-width: 45px; text-align: right; font-variant-numeric: tabular-nums; }
        .settings-button-link { display: block; background-color: #007BFF; color: white !important; text-decoration: none; padding: 12px 15px; border-radius: 8px; font-weight: bold; cursor: pointer; text-align: center; transition: background-color 0.2s; margin-top: 10px; border: none; width: 100%; box-sizing: border-box; font-size: 1em; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        .settings-button-link:hover { background-color: #0056b3; }

        /* --- СТИЛИ ДЛЯ КОМБО И ЯРОСТИ (JUICE) --- */
        
        /* Контейнер полоски комбо */
        .combo-bar-container {
            position: absolute;
            top: 95px; 
            left: 50%;
            
            /* --- ИСПРАВЛЕНИЕ: Скрываем полоску по умолчанию --- */
            transform: translateX(-50%) translateY(-20px); /* Сдвинута вверх */
            opacity: 0; /* Полностью прозрачна */
            /* -------------------------------------------------- */

            width: 50%; 
            height: 8px; 
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #555; 
            border-radius: 6px;
            z-index: 50;
            overflow: hidden;
            
            /* --- ИСПРАВЛЕНИЕ: Добавляем анимацию появления --- */
            transition: opacity 0.3s ease-out, transform 0.3s ease-out, border-color 0.3s;
            /* ------------------------------------------------- */
            
            pointer-events: none; 
        }

        /* Класс, который делает полоску видимой (ЭТОТ БЛОК У ТЕБЯ ЕСТЬ, НО ПРОВЕРЬ) */
        .combo-bar-container.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0); /* Плавный выезд на место */
        }
        
        /* Сама полоска (заполнитель) */
        .combo-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #FF9800, #FF5722); 
            width: 0%;
            transition: width 0.1s linear;
            box-shadow: 0 0 5px #FF5722;
        }

        /* Режим ЯРОСТИ (без изменений) */
        .combo-bar-container.frenzy-mode {
            border-color: #FFD700;
            box-shadow: 0 0 10px rgba(255, 69, 0, 0.5);
            opacity: 1; /* На всякий случай принудительно показываем */
            transform: translateX(-50%) translateY(0);
            animation: pulse-border 0.5s infinite alternate;
        }
        
        .combo-bar-container.frenzy-mode .combo-bar-fill {
            background: linear-gradient(90deg, #FFD700, #FF0000);
            width: 100% !important;
            animation: flicker 0.2s infinite;
        }

        /* ОБНОВЛЕННАЯ Анимация тряски (МЯГКАЯ) */
        /* Раньше сдвиг был до 3px, теперь максимум 1.5px */
        @keyframes shake-soft {
            0% { transform: translate(0.5px, 0.5px) rotate(0deg); }
            10% { transform: translate(-0.5px, -1px) rotate(-0.5deg); }
            20% { transform: translate(-1.5px, 0px) rotate(0.5deg); }
            30% { transform: translate(1.5px, 1px) rotate(0deg); }
            40% { transform: translate(0.5px, -0.5px) rotate(0.5deg); }
            50% { transform: translate(-0.5px, 1px) rotate(-0.5deg); }
            60% { transform: translate(-1.5px, 0.5px) rotate(0deg); }
            70% { transform: translate(1.5px, 0.5px) rotate(-0.5deg); }
            80% { transform: translate(-0.5px, -0.5px) rotate(0.5deg); }
            90% { transform: translate(0.5px, 1px) rotate(0deg); }
            100% { transform: translate(0.5px, -1px) rotate(-0.5deg); }
        }

        /* Класс для активации тряски на контейнере */
        .shake-active {
            animation: shake-soft 0.2s ease-in-out infinite; 
        }
        
        @keyframes flicker {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        
        @keyframes pulse-border {
            from { transform: translateX(-50%) scale(1); }
            to { transform: translateX(-50%) scale(1.02); } /* Уменьшил пульсацию масштаба */
        }

        /* --- MEDIA QUERY ДЛЯ ОЧЕНЬ УЗКИХ ЭКРАНОВ (например, iPhone SE) --- */
        @media (max-width: 375px) {
            
            /* 1. Общее уменьшение базового шрифта */
            body, html {
                font-size: 14px; 
            }
            
            /* 2. Еще более компактный хедер */
            .header-user, .header-balance {
                padding: 3px 6px;
                font-size: 0.9em;
            }
            .header-user img, .header-balance img {
                width: 30px;
                height: 30px;
            }

            /* 3. Еще более компактные кнопки на Лесном экране */
            .tasks-button, .daily-rewards-button { 
                width: 50px; 
                height: 50px; 
            }
            .settings-button { 
                width: 40px; 
                height: 40px;
            }
            .ads-button { top: 65px; width: 40px; height: 40px; 
            }
            .daily-rewards-button { top: 68px; right: 15px; } /* Сдвиг */

            /* 4. Списки (Бусты, Задания) */
            .upgrade-item, .task-item {
                padding: 6px;
            }
            .buy-btn {
                padding: 5px 8px; /* Уменьшаем кнопки покупки */
                font-size: 0.8em;
            }
            .upgrade-info .description-line, .upgrade-info .description-line-next {
                font-size: 0.8em; /* Уменьшаем текст описаний */
            }

            /* 5. Таб-бар */
            .tab-item {
                font-size: 0.8em;
            }
            .tab-item img {
                width: 30px;
                height: 30px;
            }
        }
        /* --- КОНЕЦ MEDIA QUERY --- */

        /* --- НОВЫЙ СТИЛЬ ДЛЯ ЭКРАНА "ДУПЛО" --- */
        .app-container.home-active {
            /* * ЗАМЕНА: Теперь фон по умолчанию - это Уровень 1 (bg_burrow_inside1.png).
             * Динамическая смена фона будет происходить через JavaScript (inline style).
            */
            background-image: url('images/bg_burrow_inside1.png'); /* <-- ИЗМЕНЕНО */
            background-color: #333;
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out; /* Плавный переход */
        }

        /* --- НОВЫЙ СТИЛЬ ДЛЯ ЭКРАНА "НАБЕГ" --- */
        .app-container.raid-active {
            background-image: url('images/bg_raid_darkforest.png'); /* <-- ТВОЕ НОВОЕ ИМЯ ФАЙЛА */
            background-color: #1a1a1a; /* Можно поставить темный фоллбэк */
            background-size: cover;
            background-position: center;
            transition: background-image 0.5s ease-in-out; /* Плавный переход */
        }
        
        /* Делаем прокручиваемый контент прозрачным, чтобы видеть фон */
        .app-container.home-active .game-screen-scroll {
             background: transparent;
        }
        /* --- КОНЕЦ НОВОГО СТИЛЯ --- *
        
        /* Стиль для плашек Прочности и Сейфа */
        .home-stats-bar-container {
            /* --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: АБСОЛЮТНОЕ ПОЗИЦИОНИРОВАНИЕ --- */
            position: absolute; 
            top: 100px; /* ЭТО ВАШ НОВЫЙ КОНТРОЛЬ ПОЛОЖЕНИЯ (Опускание/Поднятие) */
            left: 50%;
            transform: translateX(-50%); /* Центрирование */
            z-index: 10;
            /* ---------------------------------------------------- */
            
            display: flex;
            flex-direction: column; 
            gap: 10px;
            padding: 0; 
            
            /* Устанавливаем ширину, чтобы не выходило за границы */
            width: 90%; 
            max-width: 400px;
            
            /* Удаляем лишние margin, так как теперь управляем через 'top' */
            margin: 0; 
        }

        .home-header-image {
            text-align: center;
            margin-top: -60px; 
            margin-bottom: 0px; /* Устанавливаем в ноль, чтобы не перекрывать плашки */
        }

        .home-stat-plaque {
            width: 100%; /* Занимает 100% ширины своего контейнера */
            max-width: 400px;
            margin: 0 auto;
            
            /* --- КРИТИЧЕСКИЙ FIX: box-sizing --- */
            box-sizing: border-box; 
            /* ---------------------------------- */
            
            display: flex;
            flex-direction: column; 
            align-items: flex-start; 
            
            padding: 10px 15px; 
            border-radius: 12px;
            font-weight: bold;
            font-size: 0.9em;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .home-stat-plaque img {
            width: 20px; 
            height: 20px; 
            margin-right: 5px; 
        }

        /* --- НОВЫЕ СТИЛИ: ПРОЗРАЧНОСТЬ И ЦВЕТА --- */
        .plaque-hp {
            /* Полупрозрачный зеленый фон */
            background: rgba(76, 175, 80, 0.4); 
            border-color: rgba(76, 175, 80, 0.7); /* Более четкая зеленая рамка */
        }

        .plaque-vault {
            /* Полупрозрачный желтый фон */
            background: rgba(255, 215, 0, 0.4); 
            border-color: rgba(255, 215, 0, 0.7); /* Более четкая желтая рамка */
            color: white; /* Делаем текст белым (как в референсе) */
        }

        .plaque-vault span {
             color: white !important;
        }
        
        /* Секция управления Сейфом */
        .vault-controls {
            text-align: center;
            padding: 15px;
            margin-bottom: 25px;
            background: none
            border-radius: 15px;
        }
        .vault-controls h4 {
            color: #ccc;
            margin: 0 0 15px 0;
            font-size: 1.1em;
        }

        /* Контейнер для двух карточек улучшений (теперь без прокрутки) */
        .defense-cards-container {
            display: flex;
            gap: 15px; /* Увеличиваем отступ */
            padding: 0 15px 30px 15px;
            /* УДАЛЯЕМ overflow-x: auto; и стили прокрутки */
        }
        .defense-cards-container::-webkit-scrollbar {
            display: none;
        }

        .defense-card {
            min-width: 48%; /* Делаем карточку 48% ширины, чтобы вместить две с отступом 15px */
            flex-grow: 1; /* Позволяем им расти, чтобы закрыть всю ширину */
            flex-shrink: 0;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 15px;
            padding: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s;
        }
        .defense-card:active {
             transform: scale(0.98);
        }

        .defense-card-icon {
            width: 60px;
            height: 60px;
            margin: 0 auto 8px auto;
            background: #555;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .defense-card-icon img {
             width: 80%;
             height: 80%;
             object-fit: contain;
        }
        
        .defense-card h5 {
            font-size: 0.9em;
            margin: 5px 0;
            color: gold;
        }
        .defense-card .level {
            font-size: 0.75em;
            color: #ccc;
            margin-bottom: 5px;
        }
        
        .defense-card-cost {
            display: block;
            background-color: #38761D;
            color: white;
            padding: 5px;
            border-radius: 8px;
            margin-top: 8px;
            font-size: 0.8em;
            font-weight: bold;
        }
        .defense-card-cost.purchased {
             background-color: #3F51B5;
        }
        .defense-card-cost.max {
             background-color: #CC0000;
        }
        .defense-card-cost:disabled {
             background-color: #555;
        }

        /* --- СТИЛИ ДЛЯ ПОЛОСЫ ПРОГРЕССА В ПЛАШКАХ HOME --- */
        .stat-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.3); /* Цвет фона пустой полосы */
            border-radius: 4px;
            margin-top: 5px;
            overflow: hidden;
        }
        .stat-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        /* --- КОНЕЦ СТИЛЕЙ ПОЛОСЫ --- */
        
        /* Изменение стилей плашек для лучшего отображения */
        .home-stat-plaque {
            flex-grow: 1;
            display: flex;
            flex-direction: column; /* Изменяем направление на вертикальное */
            align-items: flex-start; /* Выравнивание текста и полосы слева */
            padding: 10px 15px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 0.9em;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .plaque-content-row {
             display: flex;
             align-items: center;
             width: 100%;
             justify-content: space-between;
             overflow: hidden; 
        }

        /* --- КРИТИЧЕСКИЙ FIX: Отключаем обрезание на вкладке Дупло --- */
        .app-container.home-active .game-screen {
             /* Этот параметр разрешает контенту (двери и плашке HP) выходить за границы */
             overflow: visible; 
        }

        /* Также, если вы используете HomeHPComponent, убедитесь, что он не обрезан */
        .app-container.home-active .game-screen-scroll {
             /* Убираем лишний padding сверху, который может оставить пустое место */
             padding-top: 0 !important; 
             /* Убедитесь, что нет overflow: hidden здесь */
             overflow-x: hidden; 
        }

        /* --- НОВЫЙ СТИЛЬ: Единая Плашка Статуса Дупла --- */
        .duplo-status-plaque {
            width: 90%; /* Занимает 90% ширины экрана */
            max-width: 400px; /* Ограничиваем максимальную ширину */
            margin: 15px auto 25px auto; /* Центрируем и добавляем верхний/нижний отступ */
            padding: 10px 15px;
            
            /* Желтый/золотой градиент с прозрачностью */
            background: rgba(255, 215, 0, 0.4); 
            border: 2px solid rgba(255, 215, 0, 0.7);
            border-radius: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            
            color: white; /* Цвет текста */
            font-weight: bold;
            display: flex; /* Используем flex для выравнивания */
            flex-direction: column; 
            gap: 5px;
        }

        .duplo-status-row {
            display: flex;
            justify-content: space-between; /* Разносим иконку/текст и значение */
            align-items: center;
            font-size: 1em;
        }
        .duplo-status-row img {
            width: 25px; 
            height: 25px;
            margin-right: 8px;
        }
        /* --- КОНЕЦ НОВОГО СТИЛЯ --- 

        /* --- СТИЛИ ДЛЯ МОДАЛЬНОГО ОКНА И КНОПОК "ДУПЛО" (по референсу) --- */

        /* Контейнер для кнопок внизу */
        .home-bottom-nav {
            position: absolute;
            bottom: 60px; /* Отступ от нижнего края (над таб-баром) */
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 400px;
            display: flex;
            gap: 10px;
            z-index: 20; /* Поверх контента, но под модальным окном */
        }

        /* Стиль самой кнопки (как на референсе) */
        .home-nav-btn {
            flex: 1; /* Кнопки делят ширину */
            padding: 12px 10px;
            font-size: 1em;
            font-weight: bold;
            color: white;
            
            /* Коричневый фон (как на референсе) */
            background-color: #4b3a2a; 
            
            /* Рамка "под дерево" (как на референсе) */
            border: 2px solid #a37b4f;
            border-top-color: #c9a37a;
            border-left-color: #c9a37a;
            
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            transition: transform 0.1s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .home-nav-btn:active {
            transform: scale(0.98);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        /* Оверлей модального окна */
        .home-modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 30;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
        }

        /* Контент модального окна (с рамкой из референса) */
        .home-modal-content {
            width: 100%;
            max-width: 380px;
            background: #3a2e22; /* Темно-коричневый фон */
            border: 4px solid #a37b4f; /* Внешняя рамка */
            outline: 2px solid #5d4a36; /* Внутренняя тень-рамка */
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            box-sizing: border-box;
            animation: fadeIn 0.2s ease-out;
        }
        
        /* Заголовок внутри модального окна */
        .home-modal-title {
            font-size: 1.4em;
            font-weight: bold;
            color: #FFD700;
            text-align: center;
            margin-top: 0;
            margin-bottom: 20px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        }
        /* --- КОНЕЦ СТИЛЕЙ "ДУПЛО" --- */
        
        /* --- ИСПРАВЛЕНИЕ: Контейнер прокрутки должен быть выше кнопок --- */
        .app-container.home-active .game-screen-scroll {
            /* Оставляем 80px внизу для кнопок навигации */
            padding-bottom: 80px !important;
        }

        .modal-back-button {
            position: absolute; 
            top: -14px;           
            left: -5px;          
            background: none;   
            border: none;       
            padding: 0;         
            cursor: pointer;
            z-index: 40;        
            border-radius: 50%; 
            transition: background-color 0.1s ease;
            width: 88px;        /* <-- НОВОЕ ЗНАЧЕНИЕ (44 * 2) */
            height: 88px;       /* <-- НОВОЕ ЗНАЧЕНИЕ (44 * 2) */
            display: flex;      
            justify-content: center; 
            align-items: center;     
        }

        .modal-back-button img {
            width: 64px; /* <-- НОВОЕ ЗНАЧЕНИЕ (32 * 2) */
            height: 64px; /* <-- НОВОЕ ЗНАЧЕНИЕ (32 * 2) */
            object-fit: contain; 
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.7)); 
        }

        .modal-back-button:active {
            background-color: rgba(255, 255, 255, 0.1); /* Легкий фон при нажатии */
        }
        
        /* Стилизация контейнера модального окна для position: relative */
        .home-modal-content {
            position: relative; /* Важно: кнопка абсолютного позиционирования будет отталкиваться от этого элемента */
            /* ... (остальные стили, которые уже есть) ... */
        }
        /* --- КОНЕЦ СТИЛЕЙ КНОПКИ НАЗАД --- */

        /* --- НОВЫЕ СТИЛИ ДЛЯ ЭКРАНА "НАБЕГ" (Вставь в конец <style>) --- */
        .raid-screen-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 15px;
            box-sizing: border-box;
            height: 100%;
        }

        .raid-title-header {
            width: 90%;
            max-width: 350px;
            padding: 10px;
            background: #4b3a2a; /* Коричневый фон, как на фото */
            border: 2px solid #a37b4f; /* Рамка "под дерево" */
            border-radius: 10px;
            text-align: center;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
        }
        .raid-title-header h2 {
            margin: 0;
            color: white;
            font-size: 1.8em;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
        }

        .raid-find-victim-btn {
            width: 90%;
            max-width: 350px;
            padding: 12px 15px;
            background: #38761d; /* Зеленый фон, как на фото */
            border: 2px solid #73a84c;
            border-top-color: #a0d478;
            border-left-color: #a0d478;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin-bottom: 30px;
        }

        .raid-find-victim-btn .raid-cost {
            display: flex;
            align-items: center;
            background: rgba(0,0,0,0.3);
            padding: 4px 8px;
            border-radius: 20px;
            font-size: 1em;
        }

        .raid-find-victim-btn:active {
            transform: scale(0.98);
        }

        .raid-log-container {
            width: 100%;
            flex-grow: 1; /* Занимает оставшееся место */
            display: flex;
            flex-direction: column;
            /* Важно: чтобы список мог скроллиться, ему нужна ограниченная высота */
            min-height: 0; 
        }
        .raid-log-container h3 {
            color: white;
            text-align: center;
            font-size: 1.3em;
            margin: 0 0 15px 0;
        }
        .raid-log-list {
            flex-grow: 1;
            overflow-y: auto; /* Позволяет списку скроллиться */
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-right: 5px; /* Место для скроллбара */
        }
        .raid-log-item {
            width: 100%;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            flex-shrink: 0; /* Предотвращает сжатие элементов */
        }
        /* Красный для тех, кто тебя ограбил */
        .raid-log-item.victim {
            background: #6a2e2c; /* Темно-красный */
            border: 2px solid #b74a47;
        }
        /* Зеленый для тех, кого ты ограбил */
        .raid-log-item.attacker {
            background: #274e13; /* Темно-зеленый */
            border: 2px solid #578a3d;
        }

        .raid-log-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            font-size: 0.9em;
        }
        .raid-log-info img {
             width: 35px;
             height: 35px;
             border-radius: 50%;
             border: 1px solid white;
        }

        .raid-avenge-btn {
            background: #38761d; /* Зеленый, как на фото */
            border: 1px solid #73a84c;
            border-radius: 8px;
            padding: 8px 10px;
            cursor: pointer;
            
            display: flex;
            align-items: center;
            gap: 5px;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }
        .raid-avenge-btn:active {
             transform: scale(0.95);
        }
        /* --- КОНЕЦ СТИЛЕЙ ДЛЯ "НАБЕГ" --- */

        /* --- НОВЫЕ СТИЛИ ДЛЯ ЭКРАНА БИТВЫ (Вставь в конец <style>) --- */

        .raid-battle-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Центрируем контент */
            height: 100%;
            padding: 20px;
            box-sizing: border-box;
            /* Убираем прокрутку на экране боя */
            overflow: hidden; 
        }

        .raid-battle-info {
            font-size: 1.2em;
            color: #ccc;
            margin-bottom: 10px;
        }

        .raid-battle-timer {
            font-size: 3em; /* Большой таймер */
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
            margin-bottom: 20px;
        }

        .raid-duplo-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            transition: transform 0.05s ease;
            /* --- ИСПРАВЛЕНИЕ: Убираем синюю обводку при фокусе/клике --- */
            outline: none; 
            -webkit-tap-highlight-color: transparent; 
            user-select: none;
        }

        .raid-duplo-btn:active {
            transform: scale(0.98);
        }

        .raid-duplo-btn img {
            width: 250px; /* Размер дупла, по которому тапаем */
            max-width: 70vw;
            height: auto;
        }

        .raid-hp-bar {
            width: 100%;
            max-width: 300px;
            height: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 20px; /* Отступ от дупла */
            border: 2px solid rgba(0,0,0,0.5);
        }

        .raid-hp-fill {
            height: 100%;
            /* Красный градиент для HP */
            background: linear-gradient(90deg, #E53935, #FFB300); 
            transition: width 0.1s linear; /* Плавное снижение HP */
        }

        .raid-hp-text {
            color: white;
            font-weight: bold;
            margin-top: 5px;
        }

        /* --- КОНЕЦ СТИЛЕЙ БИТВЫ --- */

    </style>
</head>
<body>

    <div id="loader">
        <div class="loader-spinner"></div>
        <p>Загрузка данных...</p>
    </div>

    <div id="root"></div>

    <script type="text/babel">
        
        const { useState, useEffect, useRef } = React;

        // --- Утилита Debounce (чтобы не спамить в CloudStorage) ---
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        let tapIdCounter = 0;
        
        // =================================================================
        // ФАЛЬШИВАЯ БАЗА ДАННЫХ И КОНСТАНТЫ
        // =================================================================
        
        const DAILY_REWARDS_CATALOG = [
            { day: 1, type: 'nut', value: 1000, icon: '💰', label: '1 000 $NUT' },
            { day: 2, type: 'nut', value: 5000, icon: '💰', label: '5 000 $NUT' },
            { day: 3, type: 'bonus', bonus: { type: 'madness', name: 'Безумие', multiplier: 10, duration: 10 }, icon: '⚡', label: 'x10 Клик (10с)' },
            { day: 4, type: 'nut', value: 25000, icon: '💰', label: '25 000 $NUT' },
            { day: 5, type: 'bonus', bonus: { type: 'speed', name: 'Ускорение', rate: 15, duration: 15 }, icon: '⚡', label: '+15 ⚡️/сек (15с)' },
            { day: 6, type: 'nut', value: 50000, icon: '💰', label: '50 000 $NUT' },
            { day: 7, type: 'nut', value: 100000, icon: '🎉', label: '100 000 $NUT' },
        ];
        
        // ИЗМЕНЕНО: Обновленный ключ для сброса данных у всех пользователей
        const SAVE_DATA_KEY = 'squirrelWarsSaveData_V2';
        
        // ВНИМАНИЕ: Звуковые файлы (click.mp3, music.mp3) должны быть доступны в папке 'audio/'
        const audioTap = new Audio('audio/click.mp3');
        audioTap.volume = 0.2; 
        
        const playSound = (audioElement) => {
            if (!audioElement) return; 
            audioElement.currentTime = 0;
            audioElement.play().catch(e => console.log("")); 
        };
        // ФУНКЦИЯ ДЛЯ ОБРАБОТКИ ОТСУТСТВИЯ ИЗОБРАЖЕНИЯ (FOLBACK)
            const handleImageError = (e, fallbackEmoji) => {
                e.currentTarget.style.display = 'none'; 
                const span = document.createElement('span');
                span.textContent = fallbackEmoji;
                span.style.fontSize = '2.5em';
                span.style.color = 'white';
                span.style.textShadow = '0 0 5px black';
                e.currentTarget.parentNode.insertBefore(span, e.currentTarget);
            };
        
        const RAID_DURATION_SECONDS = 30;
        const RAID_STEAL_PERCENT = 0.10;
        const RAID_SEARCH_COST = 250; // Стоимость первого поиска
        const RAID_REROLL_COST = 50;  // Стоимость "Искать другого"
        const GOLDEN_NUT_INTERVAL_S = 600; 
        const GOLDEN_NUT_DURATION_S = 10; 
        const NUT_SIZE = 75; 
        
        const BASE_BOT_RATE = 10; 
        
        const MAX_LEVEL_TAP = 100;
        const MAX_LEVEL_ENERGY_LIMIT = 20;
        const MAX_LEVEL_ENERGY_RECHARGE = 20;
        const BASE_ENERGY = 1000;
        const ENERGY_LIMIT_PER_LEVEL = 250;
        const ENERGY_RECHARGE_PER_LEVEL = 0.2;
        
        const BOOST_CATALOG = {
            multitap: { id: 'multitap', name: 'Крепкие Зубы', description: `Добыча +1 $NUT за тап (макс. ${MAX_LEVEL_TAP})`, baseCost: 500, icon: 'images/icon_multitap.png', type: 'level', maxLevel: MAX_LEVEL_TAP, emoji: '🦷' },
            energyLimit: { id: 'energyLimit', name: 'Запасливость', description: `Макс. ⚡️Энергия +${ENERGY_LIMIT_PER_LEVEL} (макс. ${MAX_LEVEL_ENERGY_LIMIT})`, baseCost: 5000, icon: 'images/icon_energy_limit.png', type: 'level', maxLevel: MAX_LEVEL_ENERGY_LIMIT, emoji: '🔋' },
            energyRecharge: { id: 'energyRecharge', name: 'Шустрые Лапки', description: `Скорость регенерации +${ENERGY_RECHARGE_PER_LEVEL}/сек (макс. ${MAX_LEVEL_ENERGY_RECHARGE})`, baseCost: 5000, icon: 'images/icon_energy_recharge.png', type: 'level', maxLevel: MAX_LEVEL_ENERGY_RECHARGE, emoji: '⚡' },
            autoBot: { id: 'autoBot', name: 'Белка-Робот', description: `Доход: +${BASE_BOT_RATE}/сек. Оффлайн работает не более 2ч.`, baseCost: 1000000, icon: 'images/icon_autotap_bot.png', type: 'once', maxLevel: 1 }
        };

        // --- НОВЫЙ КАТАЛОГ УРОВНЕЙ СЕЙФА ---
        // (Основан на вашей таблице. 0-й индекс = Уровень 1)
        const VAULT_LEVELS = [
            // Level 1 (index 0) - Базовый, бесплатный (как вы и просили)
            { level: 1, capacity: 10000, cost: 0 },
            // Level 2 (index 1) - Цена 20,000
            { level: 2, capacity: 50000, cost: 20000 },
            // Level 3 (index 2) - Цена 100,000
            { level: 3, capacity: 250000, cost: 100000 },
            // Level 4 (index 3) - Цена 400,000
            { level: 4, capacity: 1000000, cost: 400000 },
            // Level 5 (index 4) - Цена 2,000,000
            { level: 5, capacity: 5000000, cost: 2000000 },
            // Level 6 (index 5) - Цена 10,000,000
            { level: 6, capacity: 25000000, cost: 10000000 },
            // Level 7 (index 6) - Цена 40,000,000
            { level: 7, capacity: 100000000, cost: 40000000 },
            // Level 8 (index 7) - Цена 100,000,000
            { level: 8, capacity: 250000000, cost: 100000000 },
            // Level 9 (index 8) - Цена 200,000,000
            { level: 9, capacity: 500000000, cost: 200000000 },
            // Level 10 (index 9) - Цена 400,000,000
            { level: 10, capacity: 1000000000, cost: 400000000 }
        ];
        const MAX_VAULT_LEVEL = 10;
        // --- КОНЕЦ НОВОГО КАТАЛОГА ---

        // --- НОВЫЙ КАТАЛОГ УРОВНЕЙ ПРОЧНОСТИ (HP) (Основан на вашей таблице) ---
        const HP_LEVELS = [
            // Level 1 (index 0) - Бесплатно
            { level: 1, hp: 1000, cost: 0, imageName: 'bg_burrow_inside1' },
            // Level 2 (index 1)
            { level: 2, hp: 2000, cost: 5000, imageName: 'bg_burrow_inside2' },
            // Level 3 (index 2)
            { level: 3, hp: 3500, cost: 25000, imageName: 'bg_burrow_inside3' },
            // Level 4 (index 3)
            { level: 4, hp: 5000, cost: 100000, imageName: 'bg_burrow_inside4' },
            // Level 5 (index 4)
            { level: 5, hp: 7500, cost: 300000, imageName: 'bg_burrow_inside5' },
            // Level 6 (index 5)
            { level: 6, hp: 10000, cost: 1000000, imageName: 'bg_burrow_inside6' },
            // Level 7 (index 6)
            { level: 7, hp: 15000, cost: 3000000, imageName: 'bg_burrow_inside7' },
            // Level 8 (index 7)
            { level: 8, hp: 25000, cost: 10000000, imageName: 'bg_burrow_inside8' },
            // Level 9 (index 8)
            { level: 9, hp: 40000, cost: 30000000, imageName: 'bg_burrow_inside9' },
            // Level 10 (index 9)
            { level: 10, hp: 60000, cost: 100000000, imageName: 'bg_burrow_inside10' }
        ];
        const MAX_HP_LEVEL = 10;
        // --- КОНЕЦ НОВОГО КАТАЛОГА ---

        const DEFENSE_CATALOG = {
            baseHp: { 
                id: 'baseHp', 
                name: 'Укрепить Стенки', 
                description: 'Увеличивает Прочность (HP) Дупла', // <-- Новое описание
                maxLevel: MAX_HP_LEVEL, // <-- Новый maxLevel
                icon: 'images/icon_base_hp.png', 
                type: 'level', 
                emoji: '🧱' 
                // <-- Мы удалили baseCost, так как цена теперь в HP_LEVELS
            },
            vault: { id: 'vault', name: 'Увеличить Сейф', description: 'Увеличивает вместимость Сейфа', maxLevel: MAX_VAULT_LEVEL, icon: 'images/icon_vault.png', type: 'level', emoji: '💰' }
        };
        
        const TASK_CATALOG = {
            'tap_chain': [
                { id: 'tap_1', name: 'Первый хруст', type: 'tap', target: 100, reward: 150, icon: '👆', details: 'Просто нажмите на белку 100 раз, чтобы получить свою первую награду.' },
                { id: 'tap_2', name: 'Мастер клика', type: 'tap', target: 500, reward: 500, icon: '👆', details: 'Продолжайте тапать! Достигните 500 кликов для следующего приза.' },
                { id: 'tap_3', name: 'Повелитель орехов', type: 'tap', target: 1000, reward: 1000, icon: '👆', details: '1000 кликов покажут, что вы серьезно настроены.' },
                { id: 'tap_4', name: 'Турбо-палец', type: 'tap', target: 5000, reward: 2000, icon: '👆', details: '5000 кликов! Ваши пальцы еще не устали?' },
                { id: 'tap_5', name: 'Марафонец', type: 'tap', target: 10000, reward: 5000, icon: '👆', details: '10,000 кликов. Впечатляющая выносливость!' },
                { id: 'tap_6', name: 'Палец в огне', type: 'tap', target: 25000, reward: 10000, icon: '👆', details: '25,000 кликов. Вы в огне!' },
                { id: 'tap_7', name: 'Машина для кликов', type: 'tap', target: 50000, reward: 15000, icon: '👆', details: '50,000. Вы уже почти робот.' },
                { id: 'tap_8', name: 'Щелкунчик', type: 'tap', target: 100000, reward: 25000, icon: '👆', details: '100,000 кликов. Орехи трещат от страха!' },
                { id: 'tap_9', name: 'Тап-ниндзя', type: 'tap', target: 500000, reward: 50000, icon: '👆', details: '500,000. Легендарная скорость.' },
                { id: 'tap_10', name: 'Бог Кликеров', type: 'tap', target: 1000000, reward: 100000, icon: '👆', details: '1,000,000 кликов. Вы... вы прошли игру?' }
            ],
            'balance_chain': [
                { id: 'bal_1', name: 'Зажиточная белка (I)', type: 'balance', target: 1000, reward: { type: 'double_income', name: 'Двойной доход', duration: 15 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 1 000 $NUT.' },
                { id: 'bal_2', name: 'Зажиточная белка (II)', type: 'balance', target: 10000, reward: { type: 'double_income', name: 'Двойной доход', duration: 30 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 10 000 $NUT.' },
                { id: 'bal_3', name: 'Зажиточная белка (III)', type: 'balance', target: 100000, reward: { type: 'double_income', name: 'Двойной доход', duration: 45 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 100 000 $NUT.' },
                { id: 'bal_4', name: 'Белка-Капиталист (IV)', type: 'balance', target: 250000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 250 000 $NUT.' },
                { id: 'bal_5', name: 'Полный сейф (V)', type: 'balance', target: 500000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 500 000 $NUT.' },
                { id: 'bal_6', name: 'Белка-Миллионер (VI)', type: 'balance', target: 1000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 1 000 000 $NUT.' },
                { id: 'bal_7', name: 'Инвестор (VII)', type: 'balance', target: 5000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 5 000 000 $NUT.' },
                { id: 'bal_8', name: 'Магнат (VIII)', type: 'balance', target: 10000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 10 000 000 $NUT.' },
                { id: 'bal_9', name: 'Олигарх (IX)', type: 'balance', target: 50000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 50 000 000 $NUT.' },
                { id: 'bal_10', name: 'Король Белок (X)', type: 'balance', target: 100000000, reward: { type: 'double_income', name: 'Двойной доход', duration: 60 }, icon: '💰', details: 'Держите на своем балансе (не в сейфе) 100 000 000 $NUT.' }
            ],
            'total_earned_chain': [
                { id: 'earn_1', name: 'Первые деньги', type: 'milestone', target: 1000, reward: { type: 'click', value: 1 }, icon: '📈', details: 'Заработайте 1 000 $NUT (всего). Награда: +1 к силе клика (Навсегда).' },
                { id: 'earn_2', name: 'Полная копилка', type: 'milestone', target: 10000, reward: { type: 'click', value: 3 }, icon: '📈', details: 'Заработайте 10 000 $NUT (всего). Награда: +3 к силе клика (Навсегда).' },
                { id: 'earn_3', name: 'Состоятельная белка', type: 'milestone', target: 100000, reward: { type: 'click', value: 5 }, icon: '📈', details: 'Заработайте 100 000 $NUT (всего). Награда: +5 к силе клика (Навсегда).' },
                { id: 'earn_4', name: 'Первый миллион', type: 'milestone', target: 1000000, reward: { type: 'recharge', value: 1 }, icon: '📈', details: 'Заработайте 1 000 000 $NUT (всего). Награда: +1 ⚡️/сек (Навсегда).' },
                { id: 'earn_5', name: 'Полный сейф', type: 'milestone', target: 10000000, reward: { type: 'limit', value: 500 }, icon: '📈', details: 'Заработайте 10 000 000 $NUT (всего). Награда: +500 ⚡️ макс. (Навсегда).' },
                { id: 'earn_6', name: 'Миллионер', type: 'milestone', target: 100000000, reward: { type: 'limit', value: 1000 }, icon: '📈', details: 'Заработайте 100 000 000 $NUT (всего). Награда: +1000 ⚡️ макс. (Навсегда).' },
                { id: 'earn_7', name: 'Первый миллиард', type: 'milestone', target: 1000000000, reward: { type: 'limit', value: 1500 }, icon: '📈', details: 'Заработайте 1 000 000 000 $NUT (всего). Награда: +1500 ⚡️ макс. (Навсегда).' },
                { id: 'earn_8', name: 'Ореховый Магнат', type: 'milestone', target: 10000000000, reward: { type: 'limit', value: 2000 }, icon: '📈', details: 'Заработайте 10 000 000 000 $NUT (всего). Награда: +2000 ⚡️ макс. (Навсегда).' },
                { id: 'earn_9', name: 'Планетарный Банкир', type: 'milestone', target: 100000000000, reward: { type: 'limit', value: 2500 }, icon: '📈', details: 'Заработайте 100 000 000 000 $NUT (всего). Награда: +2500 ⚡️ макс. (Навсегда).' },
                { id: 'earn_10', name: 'Владыка $NUT', type: 'milestone', target: 1000000000000, reward: { type: 'limit', value: 3000 }, icon: '📈', details: 'Заработайте 1 000 000 000 000 $NUT (всего). Награда: +3000 ⚡️ макс. (Навсегда).' }
            ]
            , // <-- ВАЖНО: Поставь здесь запятую
            
            // --- НОВАЯ ЦЕПОЧКА ЗАДАНИЙ: ОХОТНИК ЗА ЗОЛОТОМ ---
            'golden_nut_chain': [
                { id: 'gn_1', name: 'Первая добыча', type: 'golden_nut', target: 1, reward: 500, icon: '🌟', details: 'Поймайте 1 Орех. (Золотые Орехи появляются случайным образом на главном экране во время игры!)' },
                { id: 'gn_2', name: 'Глаз-алмаз', type: 'golden_nut', target: 3, reward: 1500, icon: '🌟', details: 'Поймайте 3 Золотых Ореха.' },
                { id: 'gn_3', name: 'Мастер-ловец', type: 'golden_nut', target: 5, reward: 3500, icon: '🌟', details: 'Поймайте 5 Золотых Орехов.' },
                { id: 'gn_4', name: 'Золотая лихорадка', type: 'golden_nut', target: 10, reward: 7500, icon: '🌟', details: 'Поймайте 10 Золотых Орехов.' },
                { id: 'gn_5', name: 'Белка-Снайпер', type: 'golden_nut', target: 15, reward: 15000, icon: '🌟', details: 'Поймайте 15 Золотых Орехов.' },
                { id: 'gn_6', name: 'Наследник Крон', type: 'golden_nut', target: 25, reward: 30000, icon: '🌟', details: 'Поймайте 25 Золотых Орехов.' },
                { id: 'gn_7', name: 'Золотая сеть', type: 'golden_nut', target: 40, reward: 60000, icon: '🌟', details: 'Поймайте 40 Золотых Орехов.' },
                { id: 'gn_8', name: 'Хранитель казны', type: 'golden_nut', target: 60, reward: 120000, icon: '🌟', details: 'Поймайте 60 Золотых Орехов.' },
                { id: 'gn_9', name: 'Магнат Орехов', type: 'golden_nut', target: 85, reward: 250000, icon: '🌟', details: 'Поймайте 85 Золотых Орехов.' },
                { id: 'gn_10', name: 'Золотой Король', type: 'golden_nut', target: 100, reward: 500000, icon: '🌟', details: 'Поймайте 100 Золотых Орехов.' }
        ]
        // --- КОНЕЦ НОВОЙ ЦЕПОЧКИ ---
        , // <-- ВАЖНО: Поставь здесь запятую

        // --- НОВАЯ ЦЕПОЧКА: ТРАНЖИРА ---
        'spend_chain': [
            { id: 'sp_1', name: 'Пробный расход', type: 'spend', target: 100000, reward: 5000, icon: '💎', details: 'Потратьте 100 000 $NUT на любые улучшения (во вкладке "Бусты") и получите кэшбэк 5%.' },
            { id: 'sp_2', name: 'Мелкий инвестор', type: 'spend', target: 500000, reward: 25000, icon: '💎', details: 'Потратьте 500 000 $NUT на улучшения.' },
            { id: 'sp_3', name: 'Начинающий капиталист', type: 'spend', target: 2500000, reward: 125000, icon: '💎', details: 'Потратьте 2 500 000 $NUT на улучшения.' },
            { id: 'sp_4', name: 'Серьёзные вложения', type: 'spend', target: 10000000, reward: 500000, icon: '💎', details: 'Потратьте 10 000 000 $NUT на улучшения.' },
            { id: 'sp_5', name: 'Вкус денег', type: 'spend', target: 50000000, reward: 2500000, icon: '💎', details: 'Потратьте 50 000 000 $NUT на улучшения.' },
            { id: 'sp_6', name: 'Полный оборот', type: 'spend', target: 200000000, reward: 10000000, icon: '💎', details: 'Потратьте 200 000 000 $NUT на улучшения.' },
            { id: 'sp_7', name: 'Миллиардер', type: 'spend', target: 1000000000, reward: 50000000, icon: '💎', details: 'Потратьте 1 000 000 000 $NUT на улучшения.' },
            { id: 'sp_8', name: 'Ореховый магнат', type: 'spend', target: 5000000000, reward: 250000000, icon: '💎', details: 'Потратьте 5 000 000 000 $NUT на улучшения.' },
            { id: 'sp_9', name: 'Владыка средств', type: 'spend', target: 25000000000, reward: 1250000000, icon: '💎', details: 'Потратьте 25 000 000 000 $NUT на улучшения.' },
            { id: 'sp_10', name: 'Экономический гений', type: 'spend', target: 100000000000, reward: 5000000000, icon: '💎', details: 'Потратьте 100 000 000 000 $NUT на улучшения.' }
        ]
        // --- КОНЕЦ НОВОЙ ЦЕПОЧКИ ---
    };
        
        const INITIAL_RAID_LOG = [
             { id: 1, type: 'win', amount: 0, target: 'Белка_Вася' },
        ];
        
        const INITIAL_FRIENDS_LIST = [
            { id: 101, name: 'Белка_Друг1', contribution: 0 },
        ];

        const calculateCost = (baseCost, level, upgradeId) => {
            if (upgradeId === 'multitap') {
                if (level <= 40) {
                    return Math.floor(baseCost * Math.pow(1.5, level));
                } else if (level <= 60) {
                    const baseAt40 = baseCost * Math.pow(1.5, 40);
                    return Math.floor(baseAt40 * Math.pow(1.2, level - 40));
                } else if (level <= 80) {
                    const baseAt40 = baseCost * Math.pow(1.5, 40);
                    const baseAt60 = baseAt40 * Math.pow(1.2, 20); 
                    return Math.floor(baseAt60 * Math.pow(1.15, level - 60));
                } else if (level <= 100) {
                    const baseAt40 = baseCost * Math.pow(1.5, 40);
                    const baseAt60 = baseAt40 * Math.pow(1.2, 20);
                    const baseAt80 = baseAt60 * Math.pow(1.15, 20); 
                    return Math.floor(baseAt80 * Math.pow(1.1, level - 80));
                } else {
                    const baseAt40 = baseCost * Math.pow(1.5, 40);
                    const baseAt60 = baseAt40 * Math.pow(1.2, 20);
                    const baseAt80 = baseAt60 * Math.pow(1.15, 20);
                    const baseAt100 = baseAt80 * Math.pow(1.1, 20); 
                    return Math.floor(baseAt100); 
                }
            } else {
                return Math.floor(baseCost * Math.pow(1.5, level));
            }
        };

        const formatBalance = (num) => {
             if (num >= 1000000000) {
                return (num / 1000000000).toFixed(1).replace(/\.0$/, '') + ' млрд';
            }
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1).replace(/\.0$/, '') + ' млн';
            }
            if (num >= 10000) { 
                return (num / 1000).toFixed(1).replace(/\.0$/, '') + ' K';
            }
            return num.toLocaleString('ru-RU');
        };
        
        const getMilestoneRewardText = (reward) => {
            if (reward.type === 'click') return `+${reward.value} Клик`;
            if (reward.type === 'recharge') return `+${reward.value} ⚡️/сек`;
            if (reward.type === 'limit') return `+${reward.value} ⚡️`;
            return '...';
        };
        
        const defaultLevels = {
            multitap: 0, 
            energyLimit: 0, 
            energyRecharge: 0, 
            autoBot: 0,
            baseHp: 1,
            vault: 1
        };
        
        const defaultTaskLevels = { tap_chain: 0, balance_chain: 0, total_earned_chain: 0, golden_nut_chain: 0, spend_chain: 0 };
        const defaultDailyRewardsState = { currentDay: 0, lastClaimedTimestamp: null };

        // --- Инициализация Telegram WebApp ---
        const tg = window.Telegram?.WebApp;
        // Проверяем, что мы в Telegram и initData не пустая
        const isTelegram = tg && tg.initData !== ""; 

        if (isTelegram) {
            // Разворачиваем приложение на весь экран
            tg.expand();
        }

        // ------------------------------------
        // =================================================================
        // Главный Компонент Игры (App)
        // =================================================================
        function App() {
            
            const [activeTab, setActiveTab] = useState('forest');
            const [activeSquadTab, setActiveSquadTab] = useState('clan'); 
            const [balance, setBalance] = useState(0); 
            const [energy, setEnergy] = useState(BASE_ENERGY); 
            const [tapAnimations, setTapAnimations] = useState([]); 

            const [adsState, setAdsState] = useState({ count: 0, date: new Date().toDateString() });
            
            const [showBotModal, setShowBotModal] = useState(false);
            const [showUpgradeModal, setShowUpgradeModal] = useState(null); 
            const [showBonusModal, setShowBonusModal] = useState(null); 
            
            const [showGoldenNut, setShowGoldenNut] = useState(false);
            const [activeBonuses, setActiveBonuses] = useState([]); 
            const [nutPosition, setNutPosition] = useState({ x: 50, y: 50, isMovingUp: true }); 
            
            const [totalTaps, setTotalTaps] = useState(0); 
            const [totalEarned, setTotalEarned] = useState(0);
            const [totalGoldenNutsCaught, setTotalGoldenNutsCaught] = useState(0); // <-- Счетчик Орехов
            const [totalSpent, setTotalSpent] = useState(0);
            const [taskLevels, setTaskLevels] = useState(defaultTaskLevels); 
            const [showTasksModal, setShowTasksModal] = useState(false);
            const [showTaskClaimModal, setShowTaskClaimModal] = useState(null);

            const [vaultBalance, setVaultBalance] = useState(0);
            // --- ИЗМЕНЕНИЕ: Ставим базовую вместимость из нового каталога ---
            const [vaultCapacity, setVaultCapacity] = useState(VAULT_LEVELS[0].capacity); // 10,000
            
            const [levels, setLevels] = useState(defaultLevels);
            
            const [dailyRewardsState, setDailyRewardsState] = useState(defaultDailyRewardsState); 
            const [isDailyRewardAvailable, setIsDailyRewardAvailable] = useState(false);
            const [showDailyRewardsModal, setShowDailyRewardsModal] = useState(false);
            
            const [showComeBackModal, setShowComeBackModal] = useState(false); 
            
            const [showSettingsModal, setShowSettingsModal] = useState(false);
            
            const [isDataLoaded, setIsDataLoaded] = useState(false);

            const [isSquirrelActive, setIsSquirrelActive] = useState(false);
            
            const [musicVolume, setMusicVolume] = useState(50); 
            const [musicStarted, setMusicStarted] = useState(false);
            const audioMusicRef = useRef(new Audio('audio/music.mp3')); 
            
            const [offlineEarnings, setOfflineEarnings] = useState(0);
            const [showOfflineModal, setShowOfflineModal] = useState(false);

            // Состояние для принудительной перерисовки таймера каждую секунду
            const [forceRerender, setForceRerender] = useState(0); 

            const [playerName, setPlayerName] = useState('Player_Vasya'); // Дефолтное имя

            const [playerPhotoUrl, setPlayerPhotoUrl] = useState(null); // Дефолтный аватар

            // --- НОВЫЕ STATE ДЛЯ КОМБО ---
            const [combo, setCombo] = useState(0);           // Текущий процент (0-100)
            const [isFrenzy, setIsFrenzy] = useState(false); // Активен ли режим Ярости
            
            // --- НОВЫЕ СТЕЙТЫ ДЛЯ БОЯ (ДОБАВЬ ЭТО) ---
            const [raidTarget, setRaidTarget] = useState(null); // { name, hp, balance }
            const [raidBattleHP, setRaidBattleHP] = useState(0); // HP цели в текущем бою
            const [raidTimer, setRaidTimer] = useState(RAID_DURATION_SECONDS);
            const [showRaidResultModal, setShowRaidResultModal] = useState(null); // { win, amount }

            //  НОВЫЙ СТЕЙТ: Хранит "найденную" жертву до начала атаки
            const [foundTarget, setFoundTarget] = useState(null);


            // =================================================================
        // НОВАЯ ХЕЛПЕР-ФУНКЦИЯ: ГЕНЕРАЦИЯ ЖЕРТВЫ
        // =================================================================
            const generateVictim = (playerHpLevel) => {
            // 1. Определяем диапазон уровня противника (например, -1, 0, +1 от уровня игрока)
            const minLevel = Math.max(1, playerHpLevel - 1);
            const maxLevel = Math.min(MAX_HP_LEVEL, playerHpLevel + 1);
            
            // Выбираем случайный уровень в этом диапазоне
            const victimLevel = Math.floor(Math.random() * (maxLevel - minLevel + 1)) + minLevel;
            
            // 2. Получаем данные этого уровня
            const victimHpData = HP_LEVELS[victimLevel - 1]; // -1, так как массив с 0-индексом
            
            // 3. Генерируем "куш"
            // (Логика: куш зависит от стоимости прокачки этого уровня)
            // (Например, от 5% до 15% от стоимости апгрейда)
            const cost = victimHpData.cost || 5000; // Если стоимость 0 (для 1 ур), берем 5000
            const lootMin = Math.floor(cost * 0.05);
            const lootMax = Math.floor(cost * 0.15);
            
            // 4. Реальный баланс (то, что игрок украдет при 10% краже)
            // Мы делаем его в 10 раз больше, чем средний куш
            const actualBalance = (lootMin + lootMax) * 5; // (5+15)/2 * 5 = 50k. 10% = 5k

            // 5. Собираем объект жертвы
            return {
                name: 'Белка_Бот', // Имя можно будет генерировать случайнее
                level: victimLevel,
                levelName: `Дупло ${victimLevel} уровня`,
                hp: victimHpData.hp, // HP, которое нужно снести в бою
                balance: actualBalance, // Реальный баланс (для расчета 10% кражи)
                lootRange: [lootMin, lootMax] // Диапазон, который видит игрок
            };
        };
        // --- Конец новой функции ---
            
            // --- РАСЧЕТЫ БОНУСОВ ---
            let tapMultiplier = 1;
            let doubleIncomeMultiplier = 1;
            let rechargeBonus = 0; 
            let permBonusClick = 0;
            let permBonusRecharge = 0;
            let permBonusLimit = 0;

            let isInfiniteEnergy = false;
            
            const completedMilestones = TASK_CATALOG.total_earned_chain.slice(0, taskLevels.total_earned_chain);
            completedMilestones.forEach(task => {
                if (task.reward.type === 'click') permBonusClick += task.reward.value;
                if (task.reward.type === 'recharge') permBonusRecharge += task.reward.value;
                if (task.reward.type === 'limit') permBonusLimit += task.reward.value;
            });
            
            // Расчет текущих активных бонусов
            activeBonuses.forEach(bonus => {
                if (bonus.type === 'madness') tapMultiplier = bonus.multiplier;
                else if (bonus.type === 'speed') rechargeBonus = bonus.rate;
                else if (bonus.type === 'double_income') doubleIncomeMultiplier = 2;
                else if (bonus.type === 'hyperClick') { tapMultiplier = bonus.multiplier; isInfiniteEnergy = true; }

            });
            
            const baseTap = (1 + levels.multitap * 1 + permBonusClick);
            const tapValue = Math.floor((baseTap) * tapMultiplier * doubleIncomeMultiplier); 
            const maxEnergy = BASE_ENERGY + levels.energyLimit * ENERGY_LIMIT_PER_LEVEL + permBonusLimit;
            const rechargeRate = (1 + levels.energyRecharge * ENERGY_RECHARGE_PER_LEVEL) + rechargeBonus + permBonusRecharge; 
            const passiveRatePerSec = levels.autoBot > 0 ? BASE_BOT_RATE : 0; 

            const currentTapTask = TASK_CATALOG.tap_chain[taskLevels.tap_chain];
            const currentBalanceTask = TASK_CATALOG.balance_chain[taskLevels.balance_chain];
            const currentEarnedTask = TASK_CATALOG.total_earned_chain[taskLevels.total_earned_chain];
            const currentGoldenNutTask = TASK_CATALOG.golden_nut_chain[taskLevels.golden_nut_chain];
            const currentSpendTask = TASK_CATALOG.spend_chain[taskLevels.spend_chain];
            
            const completedTapTasks = (currentTapTask && totalTaps >= currentTapTask.target) ? 1 : 0;
            const completedBalanceTasks = (currentBalanceTask && balance >= currentBalanceTask.target) ? 1 : 0;
            const completedMilestoneTasks = (currentEarnedTask && totalEarned >= currentEarnedTask.target) ? 1 : 0;
            const completedGoldenNutTasks = (currentGoldenNutTask && totalGoldenNutsCaught >= currentGoldenNutTask.target) ? 1 : 0;
            const completedSpendTasks = (currentSpendTask && totalSpent >= currentSpendTask.target) ? 1 : 0;
            
            const completedTaskCount = completedTapTasks + completedBalanceTasks + completedMilestoneTasks + completedGoldenNutTasks + completedSpendTasks;

            
            const processTap = React.useCallback((tapCount, clientX, clientY, gameScreen) => {
                if (!musicStarted) {
                    if (musicVolume > 0) { 
                         audioMusicRef.current.play().catch(e => console.error("Ошибка:", e));
                    }
                    setMusicStarted(true);
                }
                
                if (activeTab !== 'forest' && activeTab !== 'raid') return; 

                // --- ЛОГИКА КОМБО (НОВОЕ) ---
                if (activeTab === 'forest') {
                    if (!isFrenzy) {
                        // Добавляем 0.5% за каждый тап
                        setCombo(prev => {
                            const newVal = prev + (1 * tapCount);
                            if (newVal >= 100) {
                                // АКТИВАЦИЯ ЯРОСТИ
                                setIsFrenzy(true);
                                playSound(audioTap); // Можно добавить отдельный звук
                                tg.HapticFeedback?.notificationOccurred('success'); // Вибрация
                                
                                // Таймер на 10 секунд
                                setTimeout(() => {
                                    setIsFrenzy(false);
                                    setCombo(0);
                                }, 10000);
                                return 100;
                            }
                            return newVal;
                        });
                    }
                }
                // -----------------------------

                // Определяем общее количество кликов/тапов
                const tapsToProcess = Math.min(tapCount, energy); 
                
                // --- ИЗМЕНЕНИЕ: В Ярости можно кликать даже с 0 энергии ---
                if (tapsToProcess <= 0 && !isInfiniteEnergy && !isFrenzy) return; 
                
                // --- ИЗМЕНЕНИЕ: Условие главного IF ---
                if (activeTab === 'forest' && (energy >= tapsToProcess || isInfiniteEnergy || isFrenzy)) { 
                    
                    // --- ИЗМЕНЕНИЕ: Расходуем энергию, только если НЕТ Ярости и НЕТ бесконечной энергии ---
                    if (!isInfiniteEnergy && !isFrenzy) {
                         setEnergy(e => e - tapsToProcess);
                    }
                    
                    setTotalTaps(t => t + tapsToProcess);

                    let totalValue = 0;
                    const newAnimations = [];
                    const rect = gameScreen.getBoundingClientRect();
                    
                    // В режиме Ярости считаем все тапы (даже если энергии было 0)
                    const actualTaps = (isInfiniteEnergy || isFrenzy) ? tapCount : tapsToProcess; 
                    
                    for (let i = 0; i < actualTaps; i++) {
                        const isCritical = Math.random() < 0.01; 
                        const critMultiplier = 5;
                        
                        // --- ИЗМЕНЕНИЕ: Умножаем на 2, если Ярость ---
                        const frenzyMult = isFrenzy ? 2 : 1;
                        
                        const currentTapValue = isCritical 
                            ? (tapValue * critMultiplier * frenzyMult) 
                            : (tapValue * frenzyMult);
                        
                        totalValue += currentTapValue;
                        
                        const animationX = clientX + (Math.random() * 20 - 10);
                        const animationY = clientY + (Math.random() * 20 - 10);

                        // Если Ярость, текст красный и жирный
                        const animColor = isFrenzy ? '#FF4500' : (isCritical ? '#FFA500' : 'gold');

                        newAnimations.push({
                            id: tapIdCounter++,
                            value: `+${currentTapValue}${isFrenzy ? '🔥' : ''}`, 
                            x: animationX - rect.left,
                            y: animationY - rect.top,
                            isCritical: isCritical,
                            color: animColor // Передаем цвет
                        });
                    }

                    playSound(audioTap);
                    
                    // Вибрация при ярости сильнее
                    if (isFrenzy) {
                        tg.HapticFeedback?.impactOccurred('heavy');
                    }

                    setBalance(b => b + totalValue);
                    setTotalEarned(t => t + totalValue);

                    setTapAnimations(prev => [...prev, ...newAnimations]);

                    setTimeout(() => {
                        setTapAnimations(prev => prev.filter(tap => !newAnimations.includes(tap)));
                    }, 1000);
                    
                    setIsSquirrelActive(true); 
                    setTimeout(() => {
                        setIsSquirrelActive(false);
                    }, 150);
                }
            }, [musicStarted, musicVolume, activeTab, energy, isInfiniteEnergy, tapValue, isFrenzy]); // <-- Добавили isFrenzy в зависимости
            
// ... (Продолжение кода App, начиная с useEffect)
              // --- ИСПРАВЛЕННАЯ ФУНКЦИЯ ЗАГРУЗКИ (ВСТАВИТЬ ВМЕСТО СТАРОЙ) ---
            useEffect(() => {
                
                const loadGameData = async () => {
                    let savedData = null;
                    
                    try {
                        if (isTelegram) {
                            // 1. Пытаемся получить имя и фото
                            try {
                                const user = tg.initDataUnsafe.user;
                                if (user) {
                                    let name = user.first_name || '';
                                    if (user.last_name) name += ' ' + user.last_name;
                                    if (!name.trim()) name = user.username || 'Player_Vasya';
                                    
                                    setPlayerName(name.trim());
                                    if (user.photo_url) setPlayerPhotoUrl(user.photo_url);
                                }
                            } catch (e) {
                                console.error("Ошибка получения профиля:", e);
                            }

                            // 2. Загрузка из Telegram Cloud
                            console.log("Загрузка из Telegram Cloud...");
                            const data = await new Promise((resolve, reject) => {
                                tg.CloudStorage.getItems([SAVE_DATA_KEY], (err, result) => {
                                    if (err) return reject(err);
                                    resolve(result);
                                });
                            });
                            
                            if (data && data[SAVE_DATA_KEY]) {
                                savedData = JSON.parse(data[SAVE_DATA_KEY]);
                            }
                            
                        } else {
                            // 3. Загрузка из LocalStorage (для тестов в браузере)
                            console.log("Загрузка из LocalStorage...");
                            const data = localStorage.getItem(SAVE_DATA_KEY);
                            if (data) {
                                savedData = JSON.parse(data);
                            }
                        }
                    } catch (e) {
                        console.error("Ошибка загрузки:", e);
                    }

                    // --- ПРИМЕНЕНИЕ ДАННЫХ ---
                    
                    // 1. Уровни
                    let initialLevels = savedData ? (savedData.levels || defaultLevels) : defaultLevels;
                    setLevels(initialLevels);
                    
                    // 2. Задачи
                    const loadedTaskLevels = (savedData && savedData.taskLevels) 
                        ? { ...defaultTaskLevels, ...savedData.taskLevels } 
                        : defaultTaskLevels;
                    
                    // 3. Подсчет пассивных бонусов для лимита и регена
                    let initialPermBonusLimit = 0;
                    let initialPermBonusRecharge = 0;
                    
                    TASK_CATALOG.total_earned_chain.slice(0, loadedTaskLevels.total_earned_chain).forEach(task => {
                        if (task.reward.type === 'limit') initialPermBonusLimit += task.reward.value;
                        if (task.reward.type === 'recharge') initialPermBonusRecharge += task.reward.value;
                    });

                    const loadedMaxEnergy = BASE_ENERGY + initialLevels.energyLimit * ENERGY_LIMIT_PER_LEVEL + initialPermBonusLimit;
                    const loadedRechargeRate = (1 + initialLevels.energyRecharge * ENERGY_RECHARGE_PER_LEVEL) + initialPermBonusRecharge;

                    let loadedEnergy = BASE_ENERGY;
                    
                    if (savedData) {
                        const savedEnergy = savedData.energy !== undefined ? savedData.energy : BASE_ENERGY;
                        const lastOnlineTimestamp = savedData.lastOnlineTimestamp || Date.now();
                        const timeDiffSeconds = Math.floor((Date.now() - lastOnlineTimestamp) / 1000);
                        
                        // Восполнение энергии оффлайн
                        if (timeDiffSeconds > 0) {
                            const regeneratedEnergy = timeDiffSeconds * loadedRechargeRate;
                            loadedEnergy = Math.min(savedEnergy + regeneratedEnergy, loadedMaxEnergy);
                        } else {
                            loadedEnergy = savedEnergy;
                        }
                        
                        setBalance(savedData.balance || 0);
                        setTaskLevels(loadedTaskLevels);
                        setDailyRewardsState(savedData.dailyRewardsState || defaultDailyRewardsState);
                        setTotalTaps(savedData.totalTaps || 0);
                        setTotalEarned(savedData.totalEarned || 0);
                        setTotalGoldenNutsCaught(savedData.totalGoldenNutsCaught || 0);
                        setTotalSpent(savedData.totalSpent || 0);
                        setMusicVolume(savedData.musicVolume !== undefined ? savedData.musicVolume : 50);
                        setVaultBalance(savedData.vaultBalance || 0);
                        setVaultCapacity(savedData.vaultCapacity || VAULT_LEVELS[0].capacity);

                        // Логика Авто-Бота (Оффлайн доход)
                        if (savedData.levels && savedData.levels.autoBot > 0) {
                            const maxOfflineTime = 7200; 
                            const effectiveTime = Math.min(timeDiffSeconds, maxOfflineTime);
                            const earnings = Math.floor(effectiveTime * BASE_BOT_RATE);

                            if (earnings > 0) {
                                setOfflineEarnings(earnings); 
                                setShowOfflineModal(true);  
                            }
                        }

                        // --- ЛОГИКА РЕКЛАМЫ ---
                        const todayStr = new Date().toDateString();
                        if (savedData.adsState && savedData.adsState.date === todayStr) {
                            setAdsState(savedData.adsState);
                        } else {
                            setAdsState({ count: 0, date: todayStr });
                        }
                    }
                    
                    setEnergy(loadedEnergy); 

                    // Проверка ежедневной награды
                    const savedTimestamp = (savedData && savedData.dailyRewardsState) ? savedData.dailyRewardsState.lastClaimedTimestamp : null;
                    const today = new Date().toDateString(); 
                    const lastClaimedDate = savedTimestamp ? new Date(savedTimestamp).toDateString() : null;
                    
                    if (today !== lastClaimedDate) {
                        setIsDailyRewardAvailable(true); 
                    }
                    
                    if (isTelegram) tg.ready(); 
                    
                    document.getElementById('loader').style.display = 'none';
                    setIsDataLoaded(true); 
                };
                
                loadGameData();
                
            }, []); // <-- Обязательный пустой массив 
            // --- НОВАЯ ЛОГИКА АВТОСОХРАНЕНИЯ КАЖДЫЕ 5 СЕКУНД ---
                        
                        // Асинхронная функция сохранения (остается такой же)
                        // Она по-прежнему умеет сохранять и в TG, и в LS
                        const saveGameData = (dataToSave) => {
                            console.log("Попытка сохранения данных...");
                            try {
                                if (isTelegram) {
                                    // --- Сохранение в Telegram CloudStorage (Асинхронно) ---
                                    new Promise((resolve, reject) => {
                                        tg.CloudStorage.setItem(SAVE_DATA_KEY, JSON.stringify(dataToSave), (err, success) => {
                                            if (err) {
                                                console.error("Ошибка сохранения в Telegram Cloud:", err);
                                                return reject(err);
                                            }
                                            if (success) {
                                                console.log("Успешно сохранено в Telegram Cloud");
                                                resolve(success);
                                            }
                                        });
                                    });
                                } else {
                                    // --- Сохранение в LocalStorage (Синхронно) ---
                                    localStorage.setItem(SAVE_DATA_KEY, JSON.stringify(dataToSave));
                                    console.log("Успешно сохранено в LocalStorage (не в TG)");
                                }
                            } catch (error) {
                                console.error("Общая ошибка сохранения данных:", error);
                                if(isTelegram) {
                                    tg.showAlert("Произошла ошибка при сохранении вашего прогресса.");
                                }
                            }
                        };

                        // --- НОВАЯ ЛОГИКА: Принудительное сохранение при закрытии/сворачивании (ФИКС БАГА) ---
                        useEffect(() => {
                            if (!isDataLoaded || !isTelegram) return;

                            const saveBeforeClose = () => {
                                const dataToSave = latestDataRef.current;
                                if (dataToSave) {
                                    console.log("CRITICAL SAVE on close/hide event...");
                                    // Запуск максимально неблокирующего сохранения
                                    saveGameData(dataToSave); 
                                }
                            };
                            
                            // 1. Обработчик: При закрытии вкладки/окна (desktop)
                            window.addEventListener('beforeunload', saveBeforeClose);
                            
                            // 2. Обработчик: При сворачивании или переключении вкладок (TWA, Android, desktop)
                            document.addEventListener('visibilitychange', () => {
                                if (document.visibilityState === 'hidden') {
                                    saveBeforeClose();
                                }
                            });

                            // 3. ДОБАВИТЬ ЭТО: Для надежного срабатывания на iOS/Safari/мобильных (более надежный, чем beforeunload)
                            window.addEventListener('pagehide', saveBeforeClose); 

                            // Очистка
                            return () => {
                                window.removeEventListener('beforeunload', saveBeforeClose);
                                document.removeEventListener('visibilitychange', saveBeforeClose);
                                window.removeEventListener('pagehide', saveBeforeClose); // <-- ОЧИСТКА
                            };
                        }, [isDataLoaded, isTelegram]);

                        // 1. Создаем "коробку" (Ref) для хранения САМЫХ СВЕЖИХ данных
                        // Это нужно, чтобы setInterval всегда имел доступ к актуальному
                        // балансу, энергии и т.д.
                        const latestDataRef = useRef();

                        // 2. Этот useEffect ОБНОВЛЯЕТ "коробку" при КАЖДОМ изменении
                        // (Он срабатывает мгновенно, но ничего не сохраняет)
                        useEffect(() => {
                            // Мы сохраняем свежие данные в "коробку",
                            // чтобы setInterval мог их "взять" в любой момент.
                            latestDataRef.current = {
                                balance,
                                energy,
                                levels,
                                taskLevels,
                                dailyRewardsState,
                                totalTaps,
                                totalEarned,
                                totalGoldenNutsCaught,
                                totalSpent,
                                musicVolume,
                                vaultBalance,
                                vaultCapacity,
                                adsState,
                                lastOnlineTimestamp: Date.now()
                            };
                        // Мы следим за всеми этими переменными
                        }, [balance, energy, levels, taskLevels, dailyRewardsState, totalTaps, totalEarned, musicVolume]); 

                        // 3. Этот useEffect запускает ТАЙМЕР, который срабатывает каждые 5 секунд
                        useEffect(() => {
                            // Убеждаемся, что начинаем сохранять только ПОСЛЕ первой загрузки
                            if (isDataLoaded) {
                                
                                // Запускаем таймер
                                const saveInterval = setInterval(() => {
                                    
                                    // Берем самые свежие данные из нашей "коробки"
                                    const dataToSave = latestDataRef.current;
                                    
                                    // Проверяем, что данные есть (на всякий случай)
                                    if (dataToSave) {
                                        // И вызываем нашу асинхронную функцию сохранения
                                        saveGameData(dataToSave);
                                    }
                                    
                                }, 2000); // <-- Вот твои 2 секунд (2000 мс)

                                // Обязательно останавливаем таймер, если компонент удаляется
                                // (например, при закрытии игры)
                                return () => clearInterval(saveInterval);
                            }
                            
                        // Этот useEffect сработает один раз, когда isDataLoaded stanet true
                        }, [isDataLoaded]); 

                        // --- КОНЕЦ НОВОЙ ЛОГИКИ АВТОСОХРАНЕНИЯ ---


            
            useEffect(() => {
                const timer = setInterval(() => {
                    setEnergy(currentEnergy => 
                        Math.min(maxEnergy, currentEnergy + rechargeRate)
                    );
                    
                    if (passiveRatePerSec > 0) {
                        const income = passiveRatePerSec; 
                        setBalance(currentBalance => currentBalance + income);
                        setTotalEarned(t => t + income); 

                        const newTap = {
                            id: tapIdCounter++,
                            value: `+${income} (Bot)`,
                            x: 250, 
                            y: 250,
                            color: 'lightblue',
                            isPassive: true
                        };
                        setTapAnimations(prev => [...prev, newTap]);

                        setTimeout(() => {
                            setTapAnimations(prev => prev.filter(tap => tap.id !== newTap.id));
                        }, 1000);
                    }
                    
                }, 1000);
                
                return () => clearInterval(timer);
            }, [maxEnergy, rechargeRate, passiveRatePerSec]); 

            // --- ОБНОВЛЕННЫЙ useEffect для управления истечением времени активных бонусов и обновления таймера ---
            useEffect(() => {
                
                const interval = setInterval(() => {
                    const now = Date.now();
                    
                    // 1. Проверяем, есть ли истекшие бонусы и удаляем их
                    setActiveBonuses(prev => {
                        const expiredBonuses = prev.filter(b => b.expiresAt <= now);
                        
                        if (expiredBonuses.length > 0) {
                            
                            // Показываем уведомление о первом истекшем бонусе
                            const firstExpired = expiredBonuses[0];
                            setShowBonusModal({
                                // --- ИЗМЕНЕНИЕ: Добавляем type: 'ended' ---
                                type: 'ended', 
                                icon: '🕰️',
                                title: 'Бонус Завершился',
                                message: `Действие бонуса «${firstExpired.name}» закончилось.`, 
                                buttonText: 'Продолжить', // <-- Меняем с 'button' на 'buttonText' для консистентности
                            });

                            // 2. Проверяем, идет ли бой, и обновляем таймер
                                                if (raidTarget) { // raidTarget НЕ null, значит, мы в бою
                                                    // (Мы не можем вызвать updateRaidTimer напрямую из-за замыкания,
                                                    // поэтому используем "безопасный" вызов setRaidTimer)
                                                    setRaidTimer(t => {
                                                        const newTime = t - 1;
                                                        if (newTime <= 0) {
                                                            handleRaidEnd(false); // Время вышло = Поражение
                                                            return 0;
                                                        }
                                                        return newTime;
                                                    });
                                                }
                                                // --- КОНЕЦ НОВОГО БЛОКА ---
                            
                            // Возвращаем только неистекшие бонусы
                            return prev.filter(b => b.expiresAt > now);
                        }
                        
                        // Если список бонусов не изменился (нет истекших), 
                        // но таймер должен идти, принудительно обновляем фиктивное состояние
                        if (prev.length > 0) {
                             setForceRerender(r => r + 1); // Принудительный ререндер для обновления отображения времени
                        }
                        
                        return prev;
                    });
                }, 1000); // Проверяем и обновляем каждую секунду
                
                return () => clearInterval(interval);
            }, [activeBonuses, raidTarget]);  
            // --- КОНЕЦ ОБНОВЛЕННОГО useEffect ---
            
            useEffect(() => {
                const MAX_X = 90; 
                const MIN_X = 5;
                const MIN_Y = 15; 
                const MAX_Y = 85; 
                
                let nutTimeoutId; 
                
                const generateInitialPosition = () => {
                    const startX = Math.floor(Math.random() * (MAX_X - MIN_X) + MIN_X);
                    const startY = Math.floor(Math.random() * (MAX_Y - MIN_Y) + MIN_Y);
                    
                    return { x: startX, y: startY, isMovingUp: Math.random() > 0.5 };
                };
                
                const showNut = () => {
                     setNutPosition(generateInitialPosition());
                     setShowGoldenNut(true);
                     
                     nutTimeoutId = setTimeout(() => {
                         setShowGoldenNut(false);
                     }, GOLDEN_NUT_DURATION_S * 1000); 
                };
                
                const initialTimeout = setTimeout(showNut, 10000); 
                const intervalId = setInterval(showNut, GOLDEN_NUT_INTERVAL_S * 1000); 
                
                return () => {
                    clearTimeout(initialTimeout);
                    clearInterval(intervalId);
                    clearTimeout(nutTimeoutId);
                };
            }, []); 

            useEffect(() => {
                let nutMoveIntervalId;
                
                if (showGoldenNut) {
                    const MAX_X = 90; 
                    const MIN_X = 5;
                    const MIN_Y = 15; 
                    const MAX_Y = 85; 
                    const Y_SPEED = 5; 
                    const X_DRIFT = 10; 

                    const moveNut = () => {
                        setNutPosition(prevPos => {
                            let newY = prevPos.y;
                            let newX = prevPos.x;
                            let isMovingUp = prevPos.isMovingUp;

                            if (isMovingUp) {
                                newY -= Y_SPEED;
                                if (newY <= MIN_Y) { 
                                    newY = MIN_Y;
                                    isMovingUp = false; 
                                }
                            } else {
                                newY += Y_SPEED;
                                if (newY >= MAX_Y) { 
                                    newY = MAX_Y;
                                    isMovingUp = true; 
                                }
                            }
                            
                            newX += (Math.random() * X_DRIFT * 2) - X_DRIFT; 
                            newX = Math.max(MIN_X, Math.min(MAX_X, newX));

                            return { x: newX, y: newY, isMovingUp: isMovingUp };
                        });
                    };
                    
                    nutMoveIntervalId = setInterval(moveNut, 1000);
                }

                return () => {
                    clearInterval(nutMoveIntervalId); 
                };
            }, [showGoldenNut]); 
            
            useEffect(() => {
                audioMusicRef.current.loop = true;
                audioMusicRef.current.volume = musicVolume / 100;
                
                if (musicVolume > 0 && musicStarted) {
                    audioMusicRef.current.play().catch(e => console.error("Ошибка воспроизведения музыки:", e));
                } else {
                    audioMusicRef.current.pause();
                }
            }, [musicVolume, musicStarted]);

            // --- ЛОГИКА ЗАТУХАНИЯ КОМБО (УСКОРЕННАЯ) ---
            useEffect(() => {
                let interval;
                if (!isFrenzy && combo > 0) {
                    interval = setInterval(() => {
                        // БЫЛО: prev - 0.5
                        // СТАЛО: prev - 2.0 (Быстрое падение, исчезнет за 5 сек)
                        setCombo(prev => Math.max(0, prev - 2.0)); 
                    }, 100);
                }
                return () => clearInterval(interval);
            }, [isFrenzy, combo]);

            // --- НОВАЯ ХЕЛПЕР-ФУНКЦИЯ ДЛЯ ДОБАВЛЕНИЯ/СУММИРОВАНИЯ БОНУСОВ (Исправленная) ---
            const addOrStackBonus = (bonusToApply) => {
                // bonusToApply теперь всегда приходит уже с expiresAt, id и type.
                
                setActiveBonuses(prev => {
                    // 1. Ищем, активен ли уже бонус этого типа
                    const existingBonusIndex = prev.findIndex(b => b.type === bonusToApply.type);
                    
                    if (existingBonusIndex !== -1) {
                        // 2. ЕСЛИ АКТИВЕН: Суммируем время
                        const existingBonus = prev[existingBonusIndex];
                        
                        // Если игрок активирует бонус, время суммируется
                        const newExpiryTime = existingBonus.expiresAt + (bonusToApply.duration || 0) * 1000;
                        
                        // Создаем обновленный бонус с новым временем
                        const updatedBonus = { ...existingBonus, expiresAt: newExpiryTime };
                        
                        // Возвращаем старый список, заменяя в нем бонус на обновленный
                        return prev.map((b, index) => 
                            index === existingBonusIndex ? updatedBonus : b
                        );
                    } else {
                        // 3. ЕСЛИ НЕ АКТИВЕН: Просто добавляем новый
                        return [...prev, bonusToApply];
                    }
                });
            };
            // --- КОНЕЦ ХЕЛПЕР-ФУНКЦИИ ---
            
            
            // --- ОБНОВЛЕННАЯ ЛОГИКА handleGoldenNutClick (ФИНАЛЬНАЯ ВЕРСИЯ) ---
            const handleGoldenNutClick = (e) => {
                 e.stopPropagation(); 

                 if (!showGoldenNut) return;

                 setTotalGoldenNutsCaught(t => t + 1); 
                 setShowGoldenNut(false);
                 
                 const bonuses = [
                     { type: 'instant', name: 'Орехопад', value: 1000, duration: 0, multiplier: 1, rate: 0 },
                     { type: 'madness', name: 'Безумие', multiplier: 10, duration: 10, rate: 0 },
                     { type: 'speed', name: 'Ускорение', rate: 15, duration: 10, multiplier: 1 },
                     { type: 'hyperClick', name: 'Гипер-клик', multiplier: 5, duration: 10, rate: 0 } 
                 ];
                 
                 const chosenBonus = bonuses[Math.floor(Math.random() * bonuses.length)];

                 // --- КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ: Зачисляем instant-бонус СРАЗУ ---
                 if (chosenBonus.type === 'instant') {
                     setBalance(b => b + chosenBonus.value); // <-- ЗДЕСЬ НАГРАДА ЗАЧИСЛЯЕТСЯ
                     setTotalEarned(t => t + chosenBonus.value); 
                     
                     setShowBonusModal({ 
                         type: 'instant',
                         icon: '🎉', 
                         title: chosenBonus.name, 
                         message: `Вы получили ${chosenBonus.value} $NUT!`, 
                         buttonText: 'Забрать',
                         bonusData: chosenBonus // Передаем объект бонуса для активации
                     });
                     
                 } else {
                     // Для временных бонусов: только показываем модальное окно (зачисление в activateBonus)
                     let message = '';
                     let icon = '⚡';
                     
                     if (chosenBonus.type === 'madness') {
                         message = `Ваш клик в ${chosenBonus.multiplier} раз сильнее на ${chosenBonus.duration} секунд!`;
                     } else if (chosenBonus.type === 'speed') {
                         message = `Регенерация энергии +${chosenBonus.rate}/сек на ${chosenBonus.duration} секунд!`;
                     } else if (chosenBonus.type === 'hyperClick') {
                         message = `Ваш клик в ${chosenBonus.multiplier} раз сильнее, а ЭНЕРГИЯ БЕСКОНЕЧНА на ${chosenBonus.duration} секунд!`;
                         icon = '👑';
                     }

                     setShowBonusModal({ 
                         type: 'timed',
                         icon: icon, 
                         title: chosenBonus.name, 
                         message: message, 
                         buttonText: `Активировать (${chosenBonus.duration}с)`,
                         bonusData: chosenBonus // Передаем объект бонуса для активации
                     });
                 }
            };
            // --- КОНЕЦ ОБНОВЛЕННОЙ ЛОГИКИ handleGoldenNutClick ---


           

            // 1. Для кликов мышью (на десктопе)
            const handleTap = (e) => {
                // Игнорируем нажатия на золотой орех, если он активен
                if (e.target.closest('.golden-nut-container')) {
                    handleGoldenNutClick(e); 
                    return;
                }
                
                const gameScreen = e.currentTarget.closest('.game-screen');
                processTap(1, e.clientX, e.clientY, gameScreen);
            };

            // 2. Для тапов (мультитач на мобильных)
            const handleTouchStart = (e) => {
                
                // Игнорируем нажатия на золотой орех, если он активен
                if (e.target.closest('.golden-nut-container')) {
                    handleGoldenNutClick(e); 
                    return;
                }
                
                const tapCount = e.touches.length; // Количество пальцев на экране
                const gameScreen = e.currentTarget.closest('.game-screen');
                
                // Используем координаты первого касания для анимации, но засчитываем все
                if (e.touches[0]) {
                    processTap(tapCount, e.touches[0].clientX, e.touches[0].clientY, gameScreen);
                }
            };
            // --- КОНЕЦ ЕДИНОГО ОБРАБОТЧИКА ---

            
            const handleBuyUpgrade = (catalog, upgradeId) => {
                const upgrade = catalog[upgradeId];
                const currentLevel = levels[upgradeId];
                
                const isMaxLevel = upgrade.type === 'level' && currentLevel >= upgrade.maxLevel;
                
                if (upgrade.type === 'once' && currentLevel > 0) {
                    alert('Этот буст уже куплен!');
                    return false; 
                }
                
                if (isMaxLevel) {
                     setShowUpgradeModal({ id: upgradeId, level: currentLevel, isMax: true });
                     return false; 
                }

                // --- НОВАЯ ЛОГИКА ДЛЯ СЕЙФА (VAULT) ---
                if (upgradeId === 'vault') {
                    // Уровень 1 (индекс 0) - бесплатный.
                    // Уровень 2 (индекс 1) - это первая покупка.
                    // Значит, нам нужны данные для УРОВНЯ (currentLevel), т.к. currentLevel - это ИНДЕКС
                    
                    const nextLevelData = VAULT_LEVELS[currentLevel]; 

                    if (nextLevelData && balance >= nextLevelData.cost) {
                        setBalance(balance - nextLevelData.cost);
                        setTotalSpent(s => s + nextLevelData.cost);
                        
                        const newLevel = currentLevel + 1;
                        setLevels(prevLevels => ({
                            ...prevLevels,
                            vault: newLevel 
                        }));
                        
                        setVaultCapacity(nextLevelData.capacity);

                        const reachedMax = newLevel === MAX_VAULT_LEVEL;
                        setShowUpgradeModal({ id: upgradeId, level: newLevel, isMax: reachedMax });

                        return true; 

                    } else if (!nextLevelData) {
                        console.error("Ошибка: Данные следующего уровня сейфа не найдены.");
                        return false; 
                     }     
                     else {
                        alert('Недостаточно $NUT!');
                        return false; 
                    }
                }
                // --- НОВАЯ ЛОГИКА ДЛЯ ПРОЧНОСТИ (BASEHP) - СКОПИРОВАНА С VAULT ---
                else if (upgradeId === 'baseHp') {
                    // currentLevel = 1 (Уровень 1)
                    // Мы покупаем Уровень 2, который находится в HP_LEVELS[1]
                    const nextLevelData = HP_LEVELS[currentLevel]; 

                    if (nextLevelData && balance >= nextLevelData.cost) {
                        setBalance(balance - nextLevelData.cost);
                        setTotalSpent(s => s + nextLevelData.cost);
                        
                        const newLevel = currentLevel + 1;
                        setLevels(prevLevels => ({
                            ...prevLevels,
                            baseHp: newLevel 
                        }));
                        
                        // (Здесь не нужно устанавливать вместимость, только уровень)

                        const reachedMax = newLevel === MAX_HP_LEVEL;
                        setShowUpgradeModal({ id: upgradeId, level: newLevel, isMax: reachedMax });

                        return true; 

                    } else if (!nextLevelData) {
                        console.error("Ошибка: Данные следующего уровня HP не найдены.");
                        return false; 
                     }     
                     else {
                        alert('Недостаточно $NUT!');
                        return false; 
                    }
                }
                    
                // --- СТАРАЯ ЛОГИКА ДЛЯ ВСЕХ ОСТАЛЬНЫХ УЛУЧШЕНИЙ (Бусты) ---
                 else {
                    
                    const cost = upgrade.type === 'once' 
                        ? upgrade.baseCost 
                        : calculateCost(upgrade.baseCost, currentLevel, upgradeId);

                    if (balance >= cost) {
                        setBalance(balance - cost);
                        setTotalSpent(s => s + cost);
                        setLevels(prevLevels => ({
                            ...prevLevels,
                            [upgradeId]: upgrade.type === 'once' ? 1 : prevLevels[upgradeId] + 1
                        }));

                        if (upgradeId === 'autoBot' && upgrade.type === 'once') {
                            setShowBotModal(true); 
                        } else if (upgrade.type === 'level') {
                            const newLevel = currentLevel + 1;
                            const reachedMax = newLevel === upgrade.maxLevel;
                            setShowUpgradeModal({ id: upgradeId, level: newLevel, isMax: reachedMax });
                        }
                        
                        if (upgradeId === 'energyLimit') {
                            const oldMaxEnergy = BASE_ENERGY + currentLevel * ENERGY_LIMIT_PER_LEVEL + permBonusLimit;
                            const newMaxEnergy = BASE_ENERGY + (currentLevel + 1) * ENERGY_LIMIT_PER_LEVEL + permBonusLimit;
                            const energyRatio = energy / oldMaxEnergy;
                            setEnergy(Math.min(newMaxEnergy, Math.ceil(newMaxEnergy * energyRatio)));
                        }
                        
                    } else {
                        alert('Недостаточно $NUT!');
                    }
                }
            };

            const handleVaultAction = (action, amount) => {
                const numAmount = Number(amount);
                if (numAmount <= 0) return;

                if (action === 'deposit') {
                    if (balance >= numAmount) {
                        // Используем функциональное обновление для vaultBalance
                        setVaultBalance(prevVaultBalance => { 
                            const newVaultBalance = prevVaultBalance + numAmount;
                            
                            if (newVaultBalance <= vaultCapacity) { // vaultCapacity здесь актуален
                                setBalance(b => b - numAmount);
                                tg.HapticFeedback?.notificationOccurred('success');
                                return newVaultBalance;
                            } else {
                                tg.HapticFeedback?.notificationOccurred('error');
                                alert(`Сейф переполнен! Максимально можно внести: ${formatBalance(vaultCapacity - prevVaultBalance)} $NUT`);
                                return prevVaultBalance; // Возвращаем старое значение
                            }
                        });
                    } else {
                         tg.HapticFeedback?.notificationOccurred('error');
                         alert('Недостаточно $NUT на балансе!');
                    }
                } else if (action === 'withdraw') {
                    // Используем функциональное обновление для vaultBalance
                    setVaultBalance(prevVaultBalance => { 
                        if (prevVaultBalance >= numAmount) {
                            setBalance(b => b + numAmount);
                            tg.HapticFeedback?.notificationOccurred('success');
                            return prevVaultBalance - numAmount;
                        } else {
                            tg.HapticFeedback?.notificationOccurred('error');
                            alert('Недостаточно $NUT в Сейфе!');
                            return prevVaultBalance; // Возвращаем старое значение
                        }
                    });
                }
            };
            
            const handleClaimTask = (taskChainId) => {
                let task;
                if (taskChainId === 'tap_chain') {
                    task = TASK_CATALOG.tap_chain[taskLevels.tap_chain];
                    if (task && totalTaps >= task.target) {
                        setShowTaskClaimModal(task);
                        setShowTasksModal(false); 
                    }
                } else if (taskChainId === 'balance_chain') {
                    task = TASK_CATALOG.balance_chain[taskLevels.balance_chain];
                    if (task && balance >= task.target) {
                        setShowTaskClaimModal(task);
                        setShowTasksModal(false); 
                    }
                // (Строка ~826)
                } else if (taskChainId === 'total_earned_chain') {
                    task = TASK_CATALOG.total_earned_chain[taskLevels.total_earned_chain];
                    if (task && totalEarned >= task.target) {
                        setShowTaskClaimModal(task);
                        setShowTasksModal(false); 
                    }
                } else if (taskChainId === 'golden_nut_chain') { // <-- ДОБАВЬ ЭТОТ БЛОК
                    task = TASK_CATALOG.golden_nut_chain[taskLevels.golden_nut_chain];
                    if (task && totalGoldenNutsCaught >= task.target) {
                        setShowTaskClaimModal(task);
                        setShowTasksModal(false); 
                    }
                } else if (taskChainId === 'spend_chain') { // <-- ДОБАВЬ ЭТОТ БЛОК
                    task = TASK_CATALOG.spend_chain[taskLevels.spend_chain];
                    if (task && totalSpent >= task.target) {
                        setShowTaskClaimModal(task);
                        setShowTasksModal(false); 
                    }
                }
            }; // <-- Конец функции

            // --- ИСПРАВЛЕННАЯ ФУНКЦИЯ ДЛЯ АКТИВАЦИИ БОНУСА И ЗАПУСКА ТАЙМЕРА ---
            const activateBonus = (bonusToActivate) => {
                // 1. Немедленные бонусы
                if (bonusToActivate.type === 'instant') {
                    // Мгновенные бонусы уже зачислены в handleGoldenNutClick,
                    // но на всякий случай, если бы мы их зачисляли здесь:
                    // setBalance(b => b + bonusToActivate.value);
                    // setTotalEarned(t => t + bonusToActivate.value);
                    
                } else {
                    // 2. Временные бонусы (madness, speed, hyperClick, double_income)
                    
                    // --- КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ: Добавляем время истечения СЕЙЧАС ---
                    const now = Date.now();
                    const bonusWithExpiry = {
                        ...bonusToActivate,
                        expiresAt: now + (bonusToActivate.duration || 0) * 1000,
                        id: Date.now() 
                    };
                    // Используем "умную" функцию для добавления/суммирования
                    addOrStackBonus(bonusWithExpiry); 
                }
                // Закрываем модальное окно после активации
                setShowBonusModal(null);
            };
            
            const confirmClaimTask = (task) => {
                if (task.type === 'tap') {
                    setBalance(b => b + task.reward);
                    setTotalEarned(t => t + task.reward);
                    setTaskLevels(prev => ({
                        ...prev,
                        tap_chain: prev.tap_chain + 1
                    }));
                } else if (task.type === 'balance') {
                    // --- ИСПРАВЛЕНИЕ ДЛЯ ОШИБКИ 'NaNc' ---
                    
                    // 1. Рассчитываем время истечения бонуса (текущее время + длительность)
                    const now = Date.now();
                    const bonusWithExpiry = { 
                        ...task.reward, // Копируем данные бонуса (type, name, duration)
                        expiresAt: now + (task.reward.duration || 0) * 1000, // <--- КЛЮЧЕВОЙ РАСЧЕТ ТАЙМЕРА
                        id: Date.now() // Уникальный ID
                    };
                    
                    // 2. Передаем полный объект бонуса с таймером в "умную" функцию
                    addOrStackBonus(bonusWithExpiry); 
                    // --- КОНЕЦ ИСПРАВЛЕНИЯ ---
                    
                    setTaskLevels(prev => ({
                        ...prev,
                        balance_chain: prev.balance_chain + 1
                    }));


                // (Строка ~856)
                } else if (task.type === 'milestone') {
                    setTaskLevels(prev => ({
                        ...prev,
                        total_earned_chain: prev.total_earned_chain + 1
                    }));
                } else if (task.type === 'golden_nut') { 
                    setBalance(b => b + task.reward);
                    setTotalEarned(t => t + task.reward);
                    setTaskLevels(prev => ({
                        ...prev,
                        golden_nut_chain: prev.golden_nut_chain + 1
                    }));
                } else if (task.type === 'spend') { // <-- ДОБАВЬ ЭТОТ БЛОК
                    setBalance(b => b + task.reward);
                    setTotalEarned(t => t + task.reward); // Кэшбэк - это тоже "заработок"
                    setTaskLevels(prev => ({
                        ...prev,
                        spend_chain: prev.spend_chain + 1
                    }));
                }

                setShowTaskClaimModal(null);
                setActiveTab('forest'); 
            };

            
            const handleClaimDailyReward = () => {
                if (!isDailyRewardAvailable) return;

                const reward = DAILY_REWARDS_CATALOG[dailyRewardsState.currentDay];
                
                // 1. Обновляем состояние на следующий день (независимо от типа награды)
                const newDailyRewardsState = {
                    currentDay: (dailyRewardsState.currentDay + 1) % 7, 
                    lastClaimedTimestamp: Date.now() 
                };
                setDailyRewardsState(newDailyRewardsState);
                setIsDailyRewardAvailable(false); 
                
                setShowDailyRewardsModal(false);

                // 2. Логика выдачи награды и отображения модального окна
                if (reward.type === 'nut') {
                    // Мгновенно зачисляем $NUT
                    setBalance(b => b + reward.value);
                    setTotalEarned(t => t + reward.value);
                    
                    // Показываем простое модальное окно уведомления
                    setShowBonusModal({
                        type: 'instant', 
                        icon: reward.icon,
                        title: 'Награда получена!',
                        message: `Вы получили: ${reward.label}!`,
                        buttonText: 'Отлично!',
                        bonusData: null // Нет данных для активации
                    });

                } else if (reward.type === 'bonus') {
                    
                    const bonusData = reward.bonus;
                    const duration = bonusData.duration;
                    let message = '';
                    let icon = '⚡';

                    // --- КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ: ГЕНЕРАЦИЯ СООБЩЕНИЯ В ЗАВИСИМОСТИ ОТ ТИПА БОНУСА ---
                    if (bonusData.type === 'madness') {
                        // Исправляет undefined, используя multiplier
                        message = `Ваш клик в ${bonusData.multiplier} раз сильнее на ${duration} секунд!`;
                    } else if (bonusData.type === 'speed') {
                        // Исправляет undefined, используя rate
                        message = `Регенерация энергии +${bonusData.rate}/сек на ${duration} секунд!`;
                    } else if (bonusData.type === 'hyperClick') {
                        // Для будущих бонусов
                        message = `Ваш клик в ${bonusData.multiplier} раз сильнее, а ЭНЕРГИЯ БЕСКОНЕЧНА на ${duration} секунд!`;
                        icon = '👑';
                    } else {
                        message = `Бонус "${bonusData.name}" активируется на ${duration} секунд!`;
                    }
                    // --- КОНЕЦ ГЕНЕРАЦИИ СООБЩЕНИЯ ---
                    
                    // Показываем модальное окно, которое запустит таймер только после нажатия кнопки
                    setShowBonusModal({ 
                        type: 'timed', // Тип, который требует активации
                        icon: icon, // Используем правильную иконку
                        title: bonusData.name, 
                        message: message, // Передаем сгенерированное сообщение
                        buttonText: `Активировать (${duration}с)`,
                        bonusData: bonusData // Передаем данные бонуса для активации в `activateBonus`
                    });
                }
            };

            // ... (после handleClaimDailyReward)

            // --- НОВЫЕ ФУНКЦИИ ДЛЯ ЛОГИКИ НАБЕГА (ЗАМЕНА) ---
            
            

            // 1. Запускается при клике на "Найти Жертву" (ПЕРВЫЙ ПОИСК)
            const handleStartRaidSearch = () => {
                if (energy < RAID_SEARCH_COST) {
                    alert("Недостаточно ⚡️Энергии для поиска!");
                    return;
                }
                // Списываем энергию
                setEnergy(e => e - RAID_SEARCH_COST);
                tg.HapticFeedback?.impactOccurred('medium');

                // Генерируем жертву на основе уровня HP игрока
                const victim = generateVictim(levels.baseHp);
                
                // Кладем жертву в "найденные", но не начинаем бой
                setFoundTarget(victim);
                // Убеждаемся, что бой не идет
                setRaidTarget(null);
            };

            // 2. Запускается при клике на "Искать другого"
            const handleRerollRaid = () => {
                if (energy < RAID_REROLL_COST) {
                    alert("Недостаточно ⚡️Энергии для нового поиска!");
                    return;
                }
                // Списываем энергию
                setEnergy(e => e - RAID_REROLL_COST);
                tg.HapticFeedback?.impactOccurred('light');

                // Генерируем НОВУЮ жертву
                const victim = generateVictim(levels.baseHp);
                setFoundTarget(victim);
            };
            
            // 3. Запускается при клике на "В АТАКУ!"
            const handleAcceptRaid = () => {
                if (!foundTarget) return; // Если цели нет, ничего не делаем

                // Перемещаем "найденную" цель в "активную" (это запустит экран боя)
                setRaidTarget(foundTarget);
                
                // Устанавливаем стейты боя
                setRaidTimer(RAID_DURATION_SECONDS); // Сбрасываем таймер
                setRaidBattleHP(foundTarget.hp); // Устанавливаем HP цели
                
                // Очищаем "найденную" цель
                setFoundTarget(null);
            };

            // 4. Запускается таймером каждую секунду (остается в useEffect)
            // (Логика в useEffect для таймера остается прежней)

            // 5. Запускается при каждом тапе по дуплу
            const handleRaidTap = () => {
                const damage = tapValue; // Урон = твоя сила клика
                
                if (raidBattleHP <= 0 || raidTimer <= 0) return;

                playSound(audioTap); // Звук клика
                tg.HapticFeedback?.impactOccurred('light');

                setRaidBattleHP(hp => {
                    const newHp = hp - damage;
                    if (newHp <= 0) {
                        handleRaidEnd(true); // Победа
                        return 0;
                    }
                    return newHp;
                });
            };

            // 6. Завершает бой (вызывается при победе или поражении)
            const handleRaidEnd = (didWin) => {
                const victim = raidTarget; // Получаем данные о жертве (теперь это raidTarget)
                
                // Сбрасываем бой (это вернет нас на главный экран Набега)
                setRaidTarget(null);
                setRaidTimer(RAID_DURATION_SECONDS);

                if (didWin && victim) {
                    tg.HapticFeedback?.notificationOccurred('success');
                    // Расчет добычи (10%)
                    const amountStolen = Math.floor(victim.balance * RAID_STEAL_PERCENT);
                    
                    setBalance(b => b + amountStolen);
                    setTotalEarned(t => t + amountStolen);
                    
                    setShowRaidResultModal({ win: true, amount: amountStolen });
                
                } else {
                    tg.HapticFeedback?.notificationOccurred('error');
                    setShowRaidResultModal({ win: false, amount: 0 });
                }
            };
            // --- КОНЕЦ НОВЫХ ФУНКЦИЙ ---
            
            


            // --- Рендеринг (Отрисовка) ---

            // --- НОВАЯ ФУНКЦИЯ: ПРОСМОТР РЕКЛАМЫ ---
            const handleWatchAd = async () => {
                // 1. Проверяем лимит (15 раз)
                if (adsState.count >= 15) {
                    tg.showAlert("На сегодня лимит рекламы исчерпан! Приходите завтра.");
                    return;
                }

                // 2. Проверяем наличие SDK
                if (!window.Adsgram) {
                    console.error("Adsgram SDK not loaded");
                    return;
                }

                // 3. Инициализируем и показываем
                const AdController = window.Adsgram.init({ blockId: "17924" });

                try {
                    const result = await AdController.show();
                    
                    if (result.done) {
                        // Успешный просмотр
                        const reward = 5000;
                        
                        setBalance(b => b + reward);
                        setTotalEarned(t => t + reward);
                        
                        // Обновляем счетчик
                        setAdsState(prev => ({
                            ...prev,
                            count: prev.count + 1
                        }));

                        // Звук и вибрация
                        playSound(audioTap);
                        tg.HapticFeedback?.notificationOccurred('success');

                        // Показываем модалку успеха
                        setShowBonusModal({
                            type: 'instant',
                            icon: '📺',
                            title: 'Реклама просмотрена!',
                            message: `Вы получили +${formatBalance(reward)} $NUT! (${adsState.count + 1}/15 на сегодня)`,
                            buttonText: 'Отлично!',
                            bonusData: null
                        });
                    }
                } catch (error) {
                    // Ошибка или пользователь закрыл рекламу рано
                    console.log("Ad skip or error:", error);
                    // Можно ничего не делать или показать алерт, если это была именно ошибка
                }
            };
            // --- КОНЕЦ ФУНКЦИИ ---
            
            const renderActiveScreen = () => {
                // Используем forceRerender в JSX, чтобы он вызывал обновление при изменении
                const timerDependentJSX = forceRerender; 

                switch(activeTab) {
                    case 'forest':
                        return (
                            <div 
                                // --- ИЗМЕНЕНИЕ: Добавляем класс shake-active при ярости ---
                                className={`forest-content ${isFrenzy ? 'shake-active' : ''}`} 
                                onClick={handleTap} 
                                onTouchStart={handleTouchStart} 
                            >
                                {/* --- ПОЛОСКА КОМБО (С ЛОГИКОЙ ПОЯВЛЕНИЯ) --- */}
                                <div 
                                    className={`combo-bar-container 
                                        ${(combo > 0 || isFrenzy) ? 'show' : ''} 
                                        ${isFrenzy ? 'frenzy-mode' : ''}`
                                    }
                                >
                                    <div 
                                        className="combo-bar-fill" 
                                        style={{ width: `${combo}%` }}
                                    ></div>
                                </div>
                                {/* ------------------------- */}

                                <ForestScreen 
                                    onTasksClick={() => setShowTasksModal(true)} 
                                    completedTasks={completedTaskCount}
                                    onDailyRewardClick={() => setShowDailyRewardsModal(true)}
                                    isDailyRewardAvailable={isDailyRewardAvailable}
                                    onSettingsClick={() => setShowSettingsModal(true)}
                                    isSquirrelActive={isSquirrelActive}
                                    onWatchAdClick={handleWatchAd}
                                    adsCount={adsState.count} 
                                />
                                
                                {/* Дальше идет твой старый код бонусов... */}
                                {activeBonuses.length > 0 && (
                                    <div className="active-bonus-indicator">
                                        {activeBonuses.map(bonus => {
                                            const timeLeft = Math.max(0, Math.floor((bonus.expiresAt - Date.now()) / 1000));
                                            
                                            let bonusText = '';
                                            
                                            if (bonus.type === 'madness') {
                                                bonusText = `⚡️ Безумие: x${bonus.multiplier} (${timeLeft}с)`;
                                            } else if (bonus.type === 'speed') {
                                                bonusText = `⚡️ Ускорение: +${bonus.rate} ⚡️/сек (${timeLeft}с)`;
                                            } else if (bonus.type === 'double_income') {
                                                bonusText = `💰 Двойной Доход (${timeLeft}с)`;
                                            } else if (bonus.type === 'hyperClick') {
                                                // --- ИСПРАВИЛ ЗДЕСЬ: Было "Гипер", стало "Гипер-Клик" ---
                                                bonusText = `👑 Гипер-Клик: x${bonus.multiplier} (${timeLeft}с)`;
                                            }

                                            return (
                                                <div key={bonus.type} className="bonus-indicator-item">
                                                    <span>{bonusText}</span>
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}

                                {/* Остальной код экрана (Орех, Анимации тапов) без изменений... */}
                                {showGoldenNut && (
                                    <div 
                                        className="golden-nut-container"
                                        onClick={handleGoldenNutClick}
                                        style={{ 
                                            top: `${nutPosition.y}%`,
                                            left: `${nutPosition.x}%`,
                                        }}
                                    >
                                        <img src="images/nut_golden_bonus.png" alt="Golden Nut" />
                                    </div>
                                )}

                                {tapAnimations.filter(t => t.color !== 'red' && !t.isPassive).map(tap => (
                                    <TapAnimation 
                                        key={tap.id} 
                                        value={tap.value} 
                                        x={tap.x} 
                                        y={tap.y} 
                                        isCritical={tap.isCritical}
                                        color={tap.color} // <-- Важно передать цвет для красных цифр
                                    />
                                ))}
                                {tapAnimations.filter(t => t.isPassive).map(tap => (
                                    <TapAnimation 
                                        key={tap.id} 
                                        value={tap.value} 
                                        x={tap.x} 
                                        y={tap.y} 
                                        color={tap.color} 
                                    />
                                ))}
                            </div>
                        );
                    case 'boosts':
                        // ... (код этой вкладки не меняется, просто скопируйте его)
                        return (
                            <div className="game-screen-scroll">
                                <BoostsScreen 
                                    levels={levels} 
                                    balance={balance} 
                                    passiveRatePerSec={passiveRatePerSec}
                                    onBuy={(id) => handleBuyUpgrade(BOOST_CATALOG, id)}
                                    
                                    permBonusClick={permBonusClick}
                                    permBonusLimit={permBonusLimit}
                                    permBonusRecharge={permBonusRecharge}
                                />
                            </div>
                        );

                    case 'home': // <--- ВОТ ЗДЕСЬ ИЗМЕНЕНИЕ
                        
                        // --- НОВАЯ ЛОГИКА: Получаем HP из массива HP_LEVELS ---
                        // levels.baseHp - это уровень (1, 2, 3...), а массив 0-индексированный
                        const currentHpData = HP_LEVELS[levels.baseHp - 1];
                        // Если данные не найдены (на всякий случай), ставим 1000
                        const currentHpValue = currentHpData ? currentHpData.hp : 1000;
                        // --- КОНЕЦ НОВОЙ ЛОГИКИ ---

                        return (
                            <div className="game-screen-scroll"> 
                                <HomeScreen 
                                    levels={levels} 
                                    balance={balance} 
                                    vaultBalance={vaultBalance} 
                                    vaultCapacity={vaultCapacity} 
                                    myBaseHp={currentHpValue} // <-- ИСПОЛЬЗУЕМ НОВОЕ ЗНАЧЕНИЕ
                                    onBuy={(id) => handleBuyUpgrade({...BOOST_CATALOG, ...DEFENSE_CATALOG}, id)} 
                                    onVaultAction={handleVaultAction} 
                                />
                            </div>
                        );

                    case 'raid':
                        // Если raidTarget установлен, мы в бою
                        if (raidTarget) {
                            return (
                                <RaidBattleScreen 
                                    target={raidTarget}
                                    battleHP={raidBattleHP}
                                    timer={raidTimer}
                                    onRaidTap={handleRaidTap}
                                    onImageError={handleImageError} 
                                />
                            );
                        } 
                        
                        // Если raidTarget = null, мы в меню (которое само решит, что показать)
                        return (
                            <div className="game-screen-scroll">
                                <RaidScreenComponent 
                                    foundTarget={foundTarget}
                                    onStartRaidSearch={handleStartRaidSearch}
                                    onAcceptRaid={handleAcceptRaid}
                                    onRerollRaid={handleRerollRaid}
                                    formatBalance={formatBalance}
                                    onImageError={handleImageError}
                                />
                            </div>
                        );

             case 'squad':
                        // ЗАМЕНА: Показываем разный контент для "Стаи"
                        return (
                            <div className="game-screen-scroll">
                                {
                                    // Используем activeSquadTab (из 'памяти'), чтобы выбрать, что показать
                                    (() => {
                                        switch(activeSquadTab) {
                                            case 'clan':
                                                return (
                                                    <div>
                                                        <div className="boost-header">
                                                            <h2>🤝 Клан (Сквад)</h2>
                                                        </div>
                                                        <div style={{ padding: '20px', textAlign: 'center', color: '#ccc' }}>
                                                            <p>Здесь будет информация о твоем клане.</p>
                                                            <p>(Тот текст "что это стая..." был здесь)</p>
                                                        </div>
                                                    </div>
                                                );
                                            case 'boss':
                                                return (
                                                    <div>
                                                        <div className="boost-header">
                                                            <h2>👹 Босс</h2>
                                                        </div>
                                                        <div style={{ padding: '20px', textAlign: 'center', color: '#ccc' }}>
                                                            <p>Здесь будет экран битвы с боссом.</p>
                                                        </div>
                                                    </div>
                                                );
                                            case 'wars':
                                                return (
                                                    <div>
                                                        <div className="boost-header">
                                                            <h2>⚔️ Войны</h2>
                                                        </div>
                                                        <div style={{ padding: '20px', textAlign: 'center', color: '#ccc' }}>
                                                            <p>Здесь будет экран для Войн Кланов.</p>
                                                        </div>
                                                    </div>
                                                );    
                                            case 'leaders':
                                                return (
                                                    <div>
                                                        <div className="boost-header">
                                                            <h2>🏆 Лидеры</h2>
                                                        </div>
                                                        <div style={{ padding: '20px', textAlign: 'center', color: '#ccc' }}>
                                                            <p>Здесь будет таблица лидеров.</p>
                                                        </div>
                                                    </div>
                                                );
                                            default:
                                                return null; // На всякий случай
                                        }
                                    })() // Сразу вызываем эту анонимную функцию
                                }
                            </div>
                        );
                    default:
                        return <div className="forest-content" onClick={handleTap} onTouchStart={handleTouchStart}><ForestScreen /></div>;
                }
            };
            
            // --- ОБНОВЛЕННЫЙ РЕНДЕР С ПРОВЕРКОЙ ЗАГРУЗКИ ---
                        
                        if (!isDataLoaded) {
                            return null;
                        }
                        
                        // --- НАЧАЛО НОВОЙ ЛОГИКИ ДЛЯ ФОНА ---
                        let appClass = "app-container";
                        let dynamicStyle = {}; // <-- НОВЫЙ ОБЪЕКТ СТИЛЕЙ

                        if (activeTab === 'home') {
                            appClass = "app-container home-active";
                            
                            // Получаем данные текущего уровня HP
                            const currentHpLevelData = HP_LEVELS[levels.baseHp - 1]; // levels.baseHp (1-10)
                            
                            // Если данные найдены, устанавливаем фон динамически
                            if (currentHpLevelData && currentHpLevelData.imageName) {
                                dynamicStyle.backgroundImage = `url('images/${currentHpLevelData.imageName}.png')`;
                            }
                            // Если не найдены, CSS (Шаг 1) применит 'bg_burrow_inside1.png'

                        } 
                        else if (activeTab === 'raid') {
                            appClass = "app-container raid-active";
                        }
                        // --- КОНЕЦ НОВОЙ ЛОГИКИ ДЛЯ ФОНА ---


                        return (
                            // --- ПРИМЕНЯЕМ СТИЛЬ ЗДЕСЬ ---
                            <div className={appClass} style={dynamicStyle}>
                                
                                <Header 
                                    balance={balance} 
                                    passiveRate={passiveRatePerSec} 
                                    playerName={playerName}
                                    playerPhotoUrl={playerPhotoUrl}
                                />
                                
                                <div className="game-screen">
                                    {renderActiveScreen()}
                                </div>
                                
                                {showBotModal && <BotPurchaseModal onClose={() => setShowBotModal(false)} rate={BASE_BOT_RATE} />}
                                {showUpgradeModal && (
                                    <UpgradeSuccessModal 
                                        upgradeId={showUpgradeModal.id}
                                        newLevel={showUpgradeModal.level}
                                        isMax={showUpgradeModal.isMax}
                                        onClose={() => setShowUpgradeModal(null)}
                                    />
                                )}
                                {showBonusModal && (
                                    <BonusNotificationModal 
                                        details={showBonusModal}
                                        onClose={() => setShowBonusModal(null)}
                                        onActivate={activateBonus}
                                    />
                                )}
                                {showTasksModal && (
                                    <TasksModal 
                                        onClose={() => setShowTasksModal(false)}
                                        totalTaps={totalTaps}
                                        balance={balance} 
                                        totalEarned={totalEarned} 
                                        totalGoldenNutsCaught={totalGoldenNutsCaught}
                                        totalSpent={totalSpent}
                                        taskLevels={taskLevels}
                                        onClaim={handleClaimTask}
                                        completedTapTasks={completedTapTasks}
                                        completedBalanceTasks={completedBalanceTasks}
                                        completedMilestoneTasks={completedMilestoneTasks}
                                        completedGoldenNutTasks={completedGoldenNutTasks}
                                        completedSpendTasks={completedSpendTasks}
                                    />
                                )}
                                
                                {showTaskClaimModal && (
                                    <TaskClaimModal
                                        task={showTaskClaimModal}
                                        onClaim={() => confirmClaimTask(showTaskClaimModal)}
                                        onClose={() => setShowTaskClaimModal(null)}
                                    />
                                )}
                                
                                {showDailyRewardsModal && (
                                    <DailyRewardsModal
                                        onClose={() => setShowDailyRewardsModal(false)}
                                        rewardsCatalog={DAILY_REWARDS_CATALOG}
                                        currentState={dailyRewardsState}
                                        isAvailable={isDailyRewardAvailable}
                                        onClaim={handleClaimDailyReward}
                                        onShowComeBackModal={() => setShowComeBackModal(true)}
                                    />
                                )}
                                
                                {showComeBackModal && (
                                    <ComeBackTomorrowModal onClose={() => setShowComeBackModal(false)} />
                                )}
                                
                                {showSettingsModal && (
                                    <SettingsModal
                                        onClose={() => setShowSettingsModal(false)}
                                        musicVolume={musicVolume}
                                        onVolumeChange={setMusicVolume}
                                    />
                                )}
                                
                                {showOfflineModal && (
                            <OfflineEarningsModal
                                earnings={offlineEarnings}
                                onClaim={() => {
                                    setBalance(b => b + offlineEarnings);
                                    setTotalEarned(t => t + offlineEarnings);
                                    setShowOfflineModal(false);
                                    setOfflineEarnings(0);
                                }}
                            />
                        )}

                        {activeTab !== 'home' && activeTab !== 'boosts' && (
                            <EnergyBar energy={energy} maxEnergy={maxEnergy} isInfinite={isInfiniteEnergy} />
                        )}

                        {/* --- НАЧАЛО ЗАМЕНЫ: Умный Таб-Бар --- */}
                        {activeTab === 'squad' ? (
                            // Если мы в "Стае", показываем новый таб-бар
                            <SquadTabBar 
                                activeTab={activeSquadTab}      // Используем "память" для стаи
                                onTabClick={setActiveSquadTab}  // Меняем "память" стаи
                                onGoHome={() => setActiveTab('forest')} // Кнопка "Главная"
                            />
                        ) : (
                            // Иначе (во всех других вкладках) показываем главный таб-бар
                            <TabBar 
                                activeTab={activeTab} 
                                onTabClick={setActiveTab} 
                            />
                        )}
                        {/* --- КОНЕЦ ЗАМЕНЫ --- */}

                        {showRaidResultModal && (
                            <RaidResultModal
                                result={showRaidResultModal}
                                onClose={() => setShowRaidResultModal(null)}
                            />
                        )}
                    
                    </div>
                        );
                    } // <-- Конец функции App


        // =================================================================
        // Компоненты Экранов и UI-элементов
        // =================================================================
        
        function OfflineEarningsModal({ earnings, onClaim }) {
            return (
                <div className="modal-overlay">
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon bot-icon">🤖</div>
                        <h3 className="success">Добро пожаловать!</h3>
                        <p>
                            Пока вас не было, ваша Белка-Робот собрала:
                        </p>
                        <p style={{fontSize: '1.5em', fontWeight: 'bold', color: 'gold', margin: '10px 0 20px 0'}}>
                           + {formatBalance(earnings)} $NUT
                        </p>
                        <button className="buy-btn" onClick={onClaim}>
                            Забрать!
                        </button>
                    </div>
                </div>
            );
        }

        
        function SettingsModal({ onClose, musicVolume, onVolumeChange }) { 
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="settings-modal" onClick={(e) => e.stopPropagation()}>
                        <h2>⚙️ Настройки</h2>
                        
                        <div className="settings-section">
                            <h3>Звук</h3>
                            <div className="settings-toggle-row">
                                <span>Громкость музыки</span>
                                <input 
                                    type="range" 
                                    min="0" 
                                    max="100" 
                                    value={musicVolume} 
                                    onChange={(e) => onVolumeChange(Number(e.target.value))} 
                                />
                                <span>{musicVolume}%</span>
                            </div>
                        </div>

                        <div className="settings-section">
                            <h3>Об игре</h3>
                            <p>
                                <strong>Squirrel Wars</strong> - это кликер.
                            </p>
                        </div>
                        
                        <div className="settings-section">
                            <h3>Обратная связь</h3>
                            <a 
                                href="https://t.me/denzzzz_7" 
                                target="_blank" 
                                rel="noopener noreferrer" 
                                className="settings-button-link"
                                style={{backgroundColor: '#E53935'}}
                            >
                                🐞 Сообщить об ошибке
                            </a>
                        </div>

                    </div>
                </div>
            );
        }

        
        function ComeBackTomorrowModal({ onClose }) {
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon level-icon">🕰️</div>
                        <h3 className="max-level">Награда недоступна</h3>
                        <p>
                            Вы уже получили сегодняшнюю награду.
                            Возвращайтесь завтра!
                        </p>
                        <button className="buy-btn" style={{backgroundColor: '#007BFF'}} onClick={onClose}>
                            Понятно
                        </button>
                    </div>
                </div>
            );
        }

        
        // НАЙТИ И ПОЛНОСТЬЮ ЗАМЕНИТЬ КОМПОНЕНТ DailyRewardsModal (строка ~2568)

function DailyRewardsModal({ onClose, rewardsCatalog, currentState, isAvailable, onClaim, onShowComeBackModal }) {
            
    const renderItem = (reward, index) => {
        const day = index + 1;
        let status = 'locked'; 
        let icon = '🔒';
        
        if (index < currentState.currentDay) {
            status = 'claimed';
            icon = '✅';
        } else if (index === currentState.currentDay && isAvailable) {
            status = 'available';
            icon = reward.icon;
        } else {
            icon = '🔒';
        }
        
        const itemClass = `daily-reward-item ${status} day-${day}`;
        
        if (status === 'available') {
            return (
                <button key={day} className={itemClass} onClick={onClaim}>
                    <div className="day-label">День {day}</div>
                    <div className="reward-icon">{icon}</div>
                    <div className="reward-label">{reward.label}</div>
                </button>
            );
        }
        
        return (
            <div 
                key={day} 
                className={itemClass}
                onClick={status === 'locked' ? onShowComeBackModal : null} 
                style={{ cursor: (status === 'locked') ? 'pointer' : 'default' }}
            >
                <div className="day-label">День {day}</div>
                <div className="reward-icon">{icon}</div>
                <div className="reward-label">
                    {status === 'claimed' ? reward.label : (status === 'locked' ? '???' : reward.label)}
                </div>
            </div>
        );
    }; // <-- Закрытие JSX-возврата
    
    // <--- КЛЮЧЕВОЕ ИСПРАВЛЕНИЕ: ДОБАВЛЯЕМ ЗАКРЫВАЮЩУЮ СКОБКУ ДЛЯ ТЕЛА renderItem!
    return (
        <div className="modal-overlay" onClick={onClose}>
            <div className="daily-rewards-modal" onClick={(e) => e.stopPropagation()}>
                <h2>🎁 Ежедневные Награды</h2>
                <div className="daily-rewards-content">
                <div className="daily-rewards-grid">
                    {rewardsCatalog.map((reward, index) => renderItem(reward, index))}
                </div>

                <button 
                    className="buy-btn" 
                    style={{backgroundColor: '#007BFF', marginTop: '25px'}} 
                    onClick={onClose}
                >
                    Закрыть
                </button>
                
                {!isAvailable && (
                    <div style={{marginTop: '20px', textAlign: 'center'}}>
                        <p style={{fontSize: '1.2em', color: 'gold', fontWeight: 'bold'}}>
                            Следующая награда будет доступна завтра!
                        </p>
                    </div>
                )}
            </div>
        </div>
    </div>
    );
} // <--- ВОТ ЗДЕСЬ ЗАКРЫВАЕТСЯ DailyRewardsModal
      
        function TaskClaimModal({ task, onClaim, onClose }) {
            let rewardMessage = '';
            let title = 'Награда получена!'; 
            let icon = task.icon;
            let buttonText = 'Забрать!';

            if (task.type === 'tap' || task.type === 'golden_nut' || task.type === 'spend') {
                rewardMessage = `Вы получаете +${formatBalance(task.reward)} $NUT!`;
                icon = '💰';
            } else if (task.type === 'balance') {
    
                rewardMessage = `Вы активируете бонус "${task.reward.name}" на ${task.reward.duration} секунд!`;
                icon = '⚡';
                buttonText = 'Активировать!';
            } else if (task.type === 'milestone') {
                rewardMessage = `Вы получаете постоянный бонус: ${getMilestoneRewardText(task.reward)}!`;
                icon = '📈';
                buttonText = 'Супер!';
            }

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon level-icon">{icon}</div>
                        <h3 className="success">{title}</h3>
                        <p style={{fontSize: '1.2em', fontWeight: 'bold', color: 'gold', marginBottom: '10px'}}>
                            {task.name}
                        </p>
                        <p>{rewardMessage}</p>
                        <button className="buy-btn" onClick={onClaim}>
                            {buttonText}
                        </button>
                    </div>
                </div>
            );
        }


        // Полная замена компонента BonusNotificationModal (~1746)

        function BonusNotificationModal({ details, onClose, onActivate }) {
             
             // Кнопка закрытия/забора/продолжения
             const handleCloseOrActivate = () => {
                 // 1. Если это временный бонус с Золотого Ореха -> Активируем таймер.
                 if (details.type === 'timed') {
                     onActivate(details.bonusData);
                 // 2. Если это истечение времени ИЛИ мгновенный бонус -> Просто закрываем.
                 } else {
                     onClose(); 
                 }
             };

             // Устанавливаем класс и цвет для модального окна
             const isEnded = details.type === 'ended';
             const titleClass = isEnded ? 'ended' : (details.type === 'instant' ? 'success' : 'max-level');
             const buttonColor = isEnded ? '#007BFF' : (details.type === 'instant' || details.type === 'timed' ? '#4CAF50' : '#007BFF');
             
            return (
                // Используем handleCloseOrActivate, чтобы модалка закрылась по клику на оверлей
                <div className="modal-overlay" onClick={handleCloseOrActivate}> 
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon level-icon">{details.icon}</div>
                        <h3 className={titleClass}>{details.title}</h3>
                        <p>
                            {details.message}
                        </p>
                        
                        <button 
                            className="buy-btn" 
                            style={{backgroundColor: buttonColor}} 
                            onClick={handleCloseOrActivate} // Вызываем нашу новую логику
                        >
                            {details.buttonText}
                        </button>
                    </div>
                </div>
            );
        }

        
        function BotPurchaseModal({ onClose, rate }) {
            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon bot-icon">🤖</div>
                        <h3>Покупка завершена!</h3>
                        <p>
                            Белка-Робот куплен! Он начинает собирать $NUT: 
                            <span style={{color: '#90EE90', fontWeight: 'bold'}}> +{rate} $NUT/сек</span>, 
                            пока вы в игре а также когда офлайн. После 2 часов офлайна останавливает свою работу!
                        </p>
                        <button className="buy-btn" style={{backgroundColor: '#007BFF'}} onClick={onClose}>
                            Отлично!
                        </button>
                    </div>
                </div>
            );
        }
        
        function UpgradeSuccessModal({ upgradeId, newLevel, isMax, onClose }) {
            const upgrade = {...BOOST_CATALOG, ...DEFENSE_CATALOG}[upgradeId];
            
            const title = isMax ? "⭐ Максимальный Уровень!" : "Улучшение завершено!";
            const titleClass = isMax ? "max-level" : "success";
            
            const message = isMax 
                ? `Вы достигли максимального уровня (${upgrade.maxLevel || 'MAX'}) для улучшения «${upgrade.name}»!`
                : `Вы успешно улучшили «${upgrade.name}» до уровня ${newLevel}!`;
            
            const icon = isMax ? '👑' : upgrade.emoji;

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                        <div className="icon level-icon">{icon}</div>
                        <h3 className={titleClass}>{title}</h3>
                        <p>{message}</p>
                        <button className="buy-btn" onClick={onClose}>
                            Продолжить
                        </button>
                    </div>
                </div>
            );
        }

        
        function LockedScreen({ tab }) {
            const tabName = {
                raid: 'Набег',
                home: 'Дупло',
                squad: 'Стая'
            }[tab];
            
            return (
                <div className="locked-screen-message">
                    <p style={{fontSize: '3em'}}>🔒</p>
                    {tabName && <h3 style={{textAlign: 'center', marginBottom: '15px'}}>{tabName}</h3>}
                    <p style={{fontSize: '1em', color: '#FFD700'}}>
                       Эта функция в разработке и будет доступна позже.
                    </p>
                </div>
            );
        }

        // Замени компонент TapAnimation на этот (чтобы поддерживал цвет текста)
        function TapAnimation({ value, x, y, color, isCritical }) {
            const style = {
                left: `${x}px`, 
                top: `${y}px`,
                // Если цвет передан (например красный при ярости), используем его. Иначе золотой.
                color: color ? color : (isCritical ? '#FFA500' : 'gold'), 
            };
            
            const animationClass = `tap-animation ${isCritical ? 'critical' : ''}`;
            
            return (
                <div className={animationClass} style={style}>
                    {value}
                </div>
            );
        }

        function Header({ balance, passiveRate, playerName, playerPhotoUrl }) { 
             const rateDisplay = passiveRate > 0 ? ` (+${passiveRate}/сек)` : '';
             const formattedBalance = formatBalance(balance);
             
             // Если playerPhotoUrl есть, используем его. 
             // Если нет, используем placeholder
             const avatarSrc = playerPhotoUrl ? playerPhotoUrl : "images/squirrel_avatar.png";

            return (
                <header className="header">
                    <div className="header-user">
                        <img src={avatarSrc} alt="User" />
                        {playerName}
                    </div>
                    
                    {/* === ВОТ ЭТОТ БЛОК У ТЕБЯ ПРОПАЛ === */}
                    <div className="header-balance">
                        <img src="images/nut_icon.png" alt="Nut" />
                        <div>
                            <span>{formattedBalance}</span>
                            {/* Показываем пассивный доход, если он есть */}
                            {rateDisplay && (
                                <span style={{fontSize: '0.6em', color: '#aaa', display: 'block', lineHeight: 1, marginTop: '2px'}}>
                                    {rateDisplay}
                                </span>
                            )}
                        </div>
                    </div>
                    {/* === КОНЕЦ ПРОПАВШЕГО БЛОКА === */}

                </header>
            );
        }

        // Компонент EnergyBar (полная замена)

        function EnergyBar({ energy, maxEnergy, isInfinite }) { 
                    
            // --- НОВАЯ ЛОГИКА ОТОБРАЖЕНИЯ И ЗНАЧЕНИЙ ---
            const percentage = isInfinite ? 100 : (energy / maxEnergy) * 100;
            const energyValue = isInfinite ? '∞' : Math.floor(energy);
            const maxValue = isInfinite ? '∞' : maxEnergy;
            // -------------------------------------------

            return (
                <div className="energy-bar-container">
                    <div className="energy-bar-label">
                        <span>⚡️ Энергия</span>
                        <span>{energyValue} / {maxValue}</span>
                    </div>
                    <div className="energy-bar-fill">
                        <div 
                            className="energy-bar-inner" 
                            style={{ 
                                width: `${percentage}%`,
                                // Меняем цвет градиента для визуала
                                background: isInfinite ? 'linear-gradient(90deg, #00BFFF, #1E90FF)' : 'linear-gradient(90deg, #64DD17, #33B760)' 
                            }}>
                        </div>
                    </div>
                </div>
            );
        }

        function TabBar({ activeTab, onTabClick }) {
            const tabs = [
                { id: 'forest', name: 'Лес', icon: 'images/icon_forest.png' },
                { id: 'boosts', name: 'Бусты', icon: 'images/icon_boosts.png' },
                { id: 'raid',   name: 'Набег', icon: 'images/icon_raid.png' },
                { id: 'home',   name: 'Дупло', icon: 'images/icon_home.png' },
                { id: 'squad',  name: 'Стая', icon: 'images/icon_friends.png' }
            ];

            return (
                <nav className="tab-bar">
                    {tabs.map(tab => (
                        <div 
                            key={tab.id}
                            className={`tab-item ${activeTab === tab.id ? 'active' : ''}`}
                            onClick={() => onTabClick(tab.id)}
                        >
                            <img src={tab.icon} alt={tab.id} />
                            <span>{tab.name}</span>
                        </div>
                    ))}
                </nav>
            );
        }

        // --- Экраны ---

        function SquadTabBar({ activeTab, onTabClick, onGoHome }) {
            // Твои кнопки: Босс, Клан, Лидеры
            const tabs = [
                // Я поменял иконки на более подходящие (потом можем заменить)
                { id: 'clan', name: 'Клан', icon: 'images/icon_friends2.png' }, // Твой "Клан(сквад)"
                { id: 'boss', name: 'Босс', icon: 'images/icon_raid.png' },   // Твой "Бос"
                { id: 'wars', name: 'Войны', icon: 'images/icon_raid.png' }, // <-- ДОБАВЬ ЭТУ СТРОКУ (иконку пока берем ту же, что и у босса)
                { id: 'leaders', name: 'Лидеры', icon: 'images/icon_boosts.png' } // Твои "Лидеры"
            ];

            return (
                <nav className="tab-bar">
                    {/* 1. Твоя кнопка "Главная" (для возврата в Лес) */}
                    <div 
                        className="tab-item"
                        onClick={onGoHome} // Эта функция вернет нас на 'forest'
                    >
                        <img src="images/icon_forest.png" alt="Главная" />
                        <span>Главная</span>
                    </div>

                    {/* 2. Остальные кнопки "Стаи" */}
                    {tabs.map(tab => (
                        <div 
                            key={tab.id}
                            className={`tab-item ${activeTab === tab.id ? 'active' : ''}`}
                            onClick={() => onTabClick(tab.id)} // Эта функция меняет activeSquadTab
                        >
                            <img src={tab.icon} alt={tab.id} />
                            <span>{tab.name}</span>
                        </div>
                    ))}
                </nav>
            );
        }

        // --- Экраны ---
        
        function ForestScreen({ 
            onTasksClick, completedTasks, onDailyRewardClick, isDailyRewardAvailable, onSettingsClick,
            isSquirrelActive,
            // --- ВАЖНО: Добавляем эти пропсы, чтобы код их видел ---
            onWatchAdClick, adsCount
            // -------------------------------------------------------
        }) {

            return (
                <div className="forest-screen">
                    <button className={`squirrel-btn ${isSquirrelActive ? 'is-active' : ''}`}>
                        <img src="images/squirrel_main_anim.png" alt="Tap me!" />
                    </button>
                    
                    {/* КНОПКА ЕЖЕДНЕВНЫХ НАГРАД */}
                    <button className="daily-rewards-button" onClick={onDailyRewardClick}>
                        <img 
                           src="images/icon_daily_rewards.png" 
                           alt="Daily Rewards" 
                           style={{width: '65px', height: '65px', flexShrink: 0}} 
                           onError={(e) => handleImageError(e, '🎁')}
                        />
                        {isDailyRewardAvailable && (
                            <div className="notification-badge">!</div>
                        )}
                    </button>
                    
                    {/* КНОПКА ЗАДАНИЙ */}
                    <button className="tasks-button" onClick={onTasksClick}>
                        <img 
                           src="images/icon_tasks.png" 
                           alt="Задания" 
                           style={{width: '65px', height: '65px', flexShrink: 0}} 
                           onError={(e) => handleImageError(e, '📋')}
                        />
                        {completedTasks > 0 && (
                            <div className="notification-badge">{completedTasks}</div>
                        )}
                    </button>
                    
                    {/* КНОПКА НАСТРОЕК */}
                    <button className="settings-button" onClick={onSettingsClick}>
                        <img 
                           src="images/icon_settings.png" 
                           alt="Настройки" 
                           style={{width: '55px', height: '55px', flexShrink: 0}} 
                           onError={(e) => handleImageError(e, '⚙️')}
                        />
                    </button>

                    {/* КНОПКА РЕКЛАМЫ (Телевизор) */}
                    {/* Теперь adsCount определен и ошибки не будет */}
                    {adsCount < 15 && (
                        <button className="ads-button" onClick={onWatchAdClick}>
                            <img 
                               src="images/icon_ads_tv.png" 
                               alt="Ads" 
                               style={{width: '45px', height: '45px', flexShrink: 0}} 
                               onError={(e) => handleImageError(e, '📺')}
                            />
                            <div className="notification-badge" style={{background: '#4CAF50'}}>
                                +5k
                            </div>
                        </button>
                    )}
                </div>
            );
        }
                

        function BoostsScreen({ 
            levels, balance, passiveRatePerSec, onBuy, 
            permBonusClick, permBonusLimit, permBonusRecharge 
        }) {
             return (
                <div className="upgrade-list">
                    <div className="boost-header">
                        <h2>🚀 Бусты (Атака и Фарм)</h2>
                    </div>
                    
                    {Object.values(BOOST_CATALOG).map(upgrade => {
                        const currentLevel = levels[upgrade.id];
                        const isMaxLevel = upgrade.type === 'level' && currentLevel >= upgrade.maxLevel;
                        
                        const cost = upgrade.type === 'once' 
                            ? upgrade.baseCost 
                            : calculateCost(upgrade.baseCost, currentLevel, upgrade.id);
                        
                        let descriptionLabel = ""; 
                        let currentValue = 0;
                        let nextValue = 0;
                        let valueSuffix = ""; 

                        if (upgrade.id === 'multitap') {
                            descriptionLabel = "Добыча:";
                            currentValue = (1 + levels.multitap * 1 + permBonusClick);
                            nextValue = (1 + (levels.multitap + 1) * 1 + permBonusClick);
                            valueSuffix = "$NUT/тап";
                        } else if (upgrade.id === 'energyLimit') {
                            descriptionLabel = "Лимит:";
                            currentValue = BASE_ENERGY + levels.energyLimit * ENERGY_LIMIT_PER_LEVEL + permBonusLimit;
                            nextValue = currentValue + ENERGY_LIMIT_PER_LEVEL;
                            valueSuffix = "⚡️";
                        } else if (upgrade.id === 'energyRecharge') {
                            descriptionLabel = "Реген:";
                            currentValue = (1 + levels.energyRecharge * ENERGY_RECHARGE_PER_LEVEL) + permBonusRecharge;
                            nextValue = currentValue + ENERGY_RECHARGE_PER_LEVEL;
                            valueSuffix = "⚡️/сек";
                        } else if (upgrade.id === 'autoBot') {
                             descriptionLabel = currentLevel > 0 
                                ? `Активен. Доход: +${passiveRatePerSec}/сек.`
                                : `Доход: +${BASE_BOT_RATE} $NUT/сек. В оффлайне работает не более 2ч.`;
                        }
                        
                        return (
                            <UpgradeItem 
                                key={upgrade.id}
                                upgrade={upgrade} 
                                level={currentLevel}
                                cost={cost}
                                canAfford={balance >= cost}
                                onBuy={() => onBuy(upgrade.id)}
                                isMaxLevel={isMaxLevel}
                                descriptionLabel={descriptionLabel}
                                currentValue={currentValue}
                                nextValue={nextValue}
                                valueSuffix={valueSuffix}
                            />
                        );
                    })}
                </div>
            );
        }

        // --- НОВЫЙ КОМПОНЕНТ: Содержимое модального окна "Сейф" ---
                function SafeManagementView({ vaultBalance, vaultCapacity, balance, onVaultAction, currentVaultLevel }) {
                    const maxDeposit = Math.min(balance, vaultCapacity - vaultBalance);
                    
                    return (
                        <div>
                            {/* --- ИЗМЕНЕНИЕ: Динамическое изображение сейфа --- */}
                            <img 
                                src={`images/vault_image${currentVaultLevel}.png`} // <-- ИСПОЛЬЗУЕМ ДИНАМИЧЕСКИЙ ПУТЬ
                                alt={`Сейф Уровень ${currentVaultLevel}`} 
                                style={{
                                    width: '80%', 
                                    height: 'auto', 
                                    display: 'block', 
                                    margin: '0 auto 15px auto', 
                                    borderRadius: '10px' 
                                }} 
                            />
                            {/* --- КОНЕЦ ИЗМЕНЕНИЯ --- */}

                            <h3 className="home-modal-title">Управление Сейфом</h3>
                            
                            {/* 1. Плашка статуса (как в HomeVaultComponent) */}
                            <div className="home-stat-plaque plaque-vault" style={{width: '100%', margin: '0 auto 20px auto'}}>                
                                
                                <div style={{display: 'flex', justifyContent: 'space-between', alignItems: 'center', width: '100%', marginBottom: '5px'}}>
                                    <div style={{display: 'flex', alignItems: 'center', gap: '5px'}}>
                                        <img src="images/nut_icon.png" alt="$NUT" style={{width: '20px', height: '20px'}}/>
                                        <span style={{fontSize: '1em', fontWeight: 'bold', color: 'white'}}>В Сейфе:</span>
                                    </div>
                                    <span style={{fontSize: '1em', fontWeight: 'bold', color: 'white'}}>
                                        {formatBalance(vaultBalance)}/{formatBalance(vaultCapacity)} $NUT
                                    </span>
                                </div>
                                <div className="stat-bar-container" style={{height: '12px'}}>
                                    <div 
                                        className="stat-bar-fill" 
                                        style={{ 
                                            width: `${(vaultBalance / vaultCapacity) * 100}%`, 
                                            background: '#FFD700'
                                        }}>
                                    </div>
                                </div>
                            </div>

                            {/* 2. Контроллы (Вложить/Забрать) */}
                            <VaultControls 
                                vaultBalance={vaultBalance}
                                currentBalance={balance}
                                maxDeposit={maxDeposit}
                                onVaultAction={onVaultAction}
                            />
                        </div>
                    );
                }
                
                


                function HomeScreen({ 
                    levels, balance, myBaseHp, onBuy, 
                    vaultBalance, vaultCapacity, onVaultAction
                }) {
                    
                    const [viewMode, setViewMode] = useState('main'); // 'main', 'safe', 'defense'

                    // --- !!! ВОТ ИЗМЕНЕНИЕ !!! ---
                    const handleDefenseBuy = (upgradeId) => {
                        // 1. Вызываем основную функцию покупки из App и получаем результат (true/false)
                        const success = onBuy(upgradeId); 

                        // 2. Если покупка не прошла, ничего не делаем (остаемся в модалке)
                        if (!success) return;

                        // 3. Если покупка прошла успешно:
                        if (upgradeId === 'vault') {
                            // Для Сейфа -> Переключаем на модалку Сейфа
                            setViewMode('safe');
                        } else if (upgradeId === 'baseHp') {
                            // Для Стен (HP) -> Закрываем модалку (возвращаемся на 'main')
                            setViewMode('main');
                        }
                        // Все остальные (если появятся) останутся в модалке
                    };
                    // --- КОНЕЦ ИЗМЕНЕНИЯ ---
            
            return (
                <div className="game-screen-scroll">
                    
                    {/* --- ИЗМЕНЕНИЕ: Показываем HP и кнопки только в 'main' режиме --- */}
                    {viewMode === 'main' && (
                        <> {/* Обертка, чтобы вернуть оба элемента */}
                            
                            {/* 1. ЭЛЕМЕНТ HP */}
                            <HomeHPComponent 
                                myBaseHp={myBaseHp} 
                                style={{ 
                                    marginTop: '15px', 
                                    zIndex: 5 
                                }}
                            />

                            {/* 2. Кнопки навигации */}
                            <div className="home-bottom-nav">
                                <button className="home-nav-btn" onClick={() => setViewMode('safe')}>
                                    <img src="images/icon_vault.png" alt="" style={{width: '18px', height: '18px', verticalAlign: 'middle', marginRight: '5px'}}/>
                                    Открыть Сейф
                                </button>
                                <button className="home-nav-btn" onClick={() => setViewMode('defense')}>
                                    <img src="images/icon_base_hp.png" alt="" style={{width: '18px', height: '18px', verticalAlign: 'middle', marginRight: '5px'}}/>
                                    Улучшить Дупло
                                </button>
                            </div>

                        </>
                    )}
                    {/* --- КОНЕЦ ИЗМЕНЕНИЯ --- */}
                    

                    {/* Модальное окно (остается без изменений) */}
                    {viewMode !== 'main' && (
                        <div className="home-modal-overlay" onClick={() => setViewMode('main')}>
                            <div className="home-modal-content" onClick={(e) => e.stopPropagation()}>
                                
                                <button 
                                    className="modal-back-button" 
                                    onClick={() => setViewMode('main')} 
                                >
                                    {/* Убедитесь, что здесь нет inline-стилей, или они правильные */}
                                    <img src="images/arrow_back.png" alt="Назад" />
                                </button>
                                
                                {viewMode === 'safe' && (
                                    <SafeManagementView
                                        vaultBalance={vaultBalance}
                                        vaultCapacity={vaultCapacity}
                                        balance={balance}
                                        onVaultAction={onVaultAction}
                                        currentVaultLevel={levels.vault} // <-- Это мы добавили в прошлый раз
                                    />
                                )}
                                
                                {viewMode === 'defense' && (
                                    <DefenseUpgradeView
                                        levels={levels}
                                        balance={balance}
                                        onBuy={handleDefenseBuy} // <-- ИСПОЛЬЗУЕМ ОБНОВЛЕННЫЙ ОБРАБОТЧИК
                                    />
                                )}
                                
                            </div>
                        </div>
                    )}

                </div>
            );    
        }
// =================================================================
// КОМПОНЕНТ "НАБЕГ" (ПОЛНАЯ ЗАМЕНА С onError)
// =================================================================
function RaidScreenComponent({ 
    foundTarget,          
    onStartRaidSearch,    
    onAcceptRaid,         
    onRerollRaid,         
    formatBalance,
    onImageError          // <-- 1. ПРИНИМАЕМ ПРОПС
}) {
    
    // Временные данные для журнала
    const raidLogData = [
        { id: 1, type: 'victim', name: 'Белка_Петя', amount: 1200000 },
        { id: 2, type: 'victim', name: 'Белка_Аня', amount: 800000 },
        { id: 3, type: 'attacker', name: 'белки_Даша', amount: 560000 }
    ];

    // --- ЭКРАН 1: КАРТОЧКА ПРОТИВНИКА ---
    if (foundTarget) {
        const [lootMin, lootMax] = foundTarget.lootRange;
        
        return (
            <div className="raid-screen-container" style={{justifyContent: 'center'}}>
                
                <div className="raid-title-header" style={{marginBottom: '30px'}}>
                    <h2>НАЙДЕНА ЖЕРТВА</h2>
                </div>

                <div style={{
                    width: '90%', 
                    maxWidth: '350px', 
                    background: '#3a2e22', 
                    border: '4px solid #a37b4f', 
                    borderRadius: '10px', 
                    padding: '20px', 
                    boxSizing: 'border-box', 
                    textAlign: 'center',
                    boxShadow: '0 5px 15px rgba(0,0,0,0.5)'
                }}>
                    <img 
                        src="images/squirrel_avatar_placeholder.png" 
                        alt="Avatar" 
                        style={{width: '80px', height: '80px', borderRadius: '50%', border: '3px solid #c9a37a'}}
                        onError={(e) => onImageError(e, '👤')} // <-- 2. ДОБАВЛЕНО
                    />
                    <h3 style={{color: 'white', margin: '10px 0 5px 0'}}>{foundTarget.name}</h3>
                    <p style={{color: '#ccc', margin: '0 0 20px 0', fontSize: '0.9em'}}>
                        {foundTarget.levelName} (HP: ~{formatBalance(foundTarget.hp)})
                    </p>
                    
                    <div style={{color: 'gold', fontWeight: 'bold', fontSize: '1.2em', marginBottom: '25px'}}>
                        Возможный куш:<br/>
                        {formatBalance(lootMin)} - {formatBalance(lootMax)} $NUT
                    </div>
                    
                    <button 
                        className="raid-find-victim-btn" 
                        style={{width: '100%', marginBottom: '10px'}}
                        onClick={onAcceptRaid}
                    >
                        <span>⚔️ В АТАКУ!</span>
                    </button>
                    
                    <button 
                        className="home-nav-btn" // Используем коричневый стиль
                        style={{width: '100%'}}
                        onClick={onRerollRaid}
                    >
                        {/* ИСПОЛЬЗУЕМ КОНСТАНТУ */}
                        <span>Искать другого (-{RAID_REROLL_COST} ⚡️)</span>
                    </button>
                </div>

            </div>
        );
    }

    // --- ЭКРАН 2: ГЛАВНОЕ МЕНЮ (старый экран) ---
    return (
        <div className="raid-screen-container">
            
            <div className="raid-title-header">
                <h2>НАБЕГ</h2>
            </div>

            <button className="raid-find-victim-btn" onClick={onStartRaidSearch}> 
                <img 
                    src="images/icon_find_victim.png" 
                    alt="Найти" 
                    style={{width: '30px', height: '30px'}}
                    onError={(e) => onImageError(e, '⚔️')} // <-- 2. ДОБАВЛЕНО
                />
                <span>НАЙТИ ЖЕРТВУ</span>
                <div className="raid-cost">
                    <span>{RAID_SEARCH_COST}</span>
                    <img 
                        src="images/icon_energy_bolt.png" 
                        alt="энергия" 
                        style={{width: '20px', height: '20px'}}
                        onError={(e) => onImageError(e, '⚡️')} // <-- 2. ДОБАВЛЕНО
                    />
                </div>
            </button>

            <div className="raid-log-container">
                <h3>Журнал Набегов</h3>
                
                <div className="raid-log-list">
                    {raidLogData.map(log => (
                        <div key={log.id} className={`raid-log-item ${log.type === 'victim' ? 'victim' : 'attacker'}`}>
                            <div className="raid-log-info">
                                <img 
                                    src="images/squirrel_avatar_placeholder.png" 
                                    alt="avatar" 
                                    onError={(e) => onImageError(e, '👤')} // <-- 2. ДОБАВЛЕНО
                                />
                                <span>
                                    {/* ... (текст лога) ... */}
                                </span>
                            </div>
                            <button className="raid-avenge-btn">
                                <img 
                                    src="images/icon_avenge.png" 
                                    alt="Отомстить"
                                    onError={(e) => onImageError(e, '⚡️')} // <-- 2. ДОБАВЛЕНО
                                />
                                <span>ОТОМСТИТЬ!</span>
                            </button>
                        </div>
                    ))}
                </div>
            </div>

        </div>
    );
}

        // НОВЫЙ КОМПОНЕНТ: Экран Битвы
// =================================================================
function RaidBattleScreen({ target, battleHP, timer, onRaidTap, onImageError }) {
    
    // Рассчитываем процент HP для полосы
    const hpPercent = (battleHP / target.hp) * 100;

    return (
        <div className="raid-battle-container">
            {/* 1. Информация о цели */}
            <div className="raid-battle-info">
                Набег на: <strong style={{color: 'gold'}}>{target.name}</strong>
            </div>

            {/* 2. Таймер */}
            <div className="raid-battle-timer">
                {timer}с
            </div>

            {/* 3. Кнопка "Дупло" (по ней тапаем) */}
            <button className="raid-duplo-btn" onClick={onRaidTap}>
                {/* ВНИМАНИЕ: Тебе понадобится картинка:
                'images/duplo_target.png' (Изображение дупла для атаки)
                */}
                <img 
                    src="images/duplo_target.png" 
                    alt="Атаковать Дупло" 
                    onError={(e) => onImageError(e, '🎯')}
                />
            </button>
            
            {/* 4. Полоса HP цели */}
            <div className="raid-hp-bar">
                <div 
                    className="raid-hp-fill" 
                    style={{ width: `${hpPercent}%` }}
                ></div>
            </div>
            <div className="raid-hp-text">
                Прочность: {Math.floor(battleHP)} / {target.hp}
            </div>
        </div>
    );
}

// =================================================================
// НОВЫЙ КОМПОНЕНТ: Модальное окно Результатов Набега
// =================================================================
function RaidResultModal({ result, onClose }) {
    const isWin = result.win;
    const title = isWin ? "🔥 ПОБЕДА! 🔥" : "Поражение";
    const titleClass = isWin ? "success" : "ended";
    const icon = isWin ? "💰" : "☠️";
    
    return (
        <div className="modal-overlay" onClick={onClose}>
            <div className="app-modal" onClick={(e) => e.stopPropagation()}>
                <div className="icon level-icon">{icon}</div>
                <h3 className={titleClass}>{title}</h3>
                
                {isWin ? (
                    <p>
                        Отличный набег! Вы успешно ограбили дупло и украли:
                        <strong style={{color: 'gold', fontSize: '1.2em', display: 'block', margin: '10px 0'}}>
                            {formatBalance(result.amount)} $NUT
                        </strong>
                    </p>
                ) : (
                    <p>
                        Время вышло! Защита дупла оказалась слишком крепкой.
                        <br/>
                        Вы ничего не украли.
                    </p>
                )}
                
                <button className="buy-btn" onClick={onClose}>
                    Выйти
                </button>
            </div>
        </div>
    );
}

        function SquadScreen({ friendsList, nutBonus, onCollectBonus }) {
            return null;
        }
        
        // (Строка ~1338)
        function TasksModal({ 
            onClose, totalTaps, balance, totalEarned, totalGoldenNutsCaught, totalSpent, taskLevels, onClaim, 
            completedTapTasks, completedBalanceTasks, completedMilestoneTasks, completedGoldenNutTasks, completedSpendTasks
        }) {
            
            const [activeTaskTab, setActiveTaskTab] = useState('tap');
            
            const [infoTaskId, setInfoTaskId] = useState(null); 
            
            const tapTaskLevel = taskLevels.tap_chain;
            const tapTask = TASK_CATALOG.tap_chain[tapTaskLevel];
            
            const balanceTaskLevel = taskLevels.balance_chain;
            const balanceTask = TASK_CATALOG.balance_chain[balanceTaskLevel];
            
            const earnedTaskLevel = taskLevels.total_earned_chain;
            const earnedTask = TASK_CATALOG.total_earned_chain[earnedTaskLevel];

            const goldenNutTaskLevel = taskLevels.golden_nut_chain; 
            const goldenNutTask = TASK_CATALOG.golden_nut_chain[goldenNutTaskLevel]; 
            const spendTaskLevel = taskLevels.spend_chain;
            const spendTask = TASK_CATALOG.spend_chain[spendTaskLevel];
            
            const infoTask = infoTaskId 
                ? (TASK_CATALOG.tap_chain.find(t => t.id === infoTaskId) || 
                   TASK_CATALOG.balance_chain.find(t => t.id === infoTaskId) ||
                   TASK_CATALOG.total_earned_chain.find(t => t.id === infoTaskId) ||
                   TASK_CATALOG.golden_nut_chain.find(t => t.id === infoTaskId) ||
                   TASK_CATALOG.spend_chain.find(t => t.id === infoTaskId)) 
                : null;
                
            const renderTabContent = () => {
                switch(activeTaskTab) {
                    case 'tap':
                        return (
                            <> {/* <-- ОБЩИЙ ФРАГМЕНТ НАЧАЛО */}
                                {tapTask ? (
                                    <TaskItem 
                                        task={tapTask} 
                                        currentProgress={totalTaps} 
                                        onClaim={() => onClaim('tap_chain')} 
                                        onShowInfo={() => setInfoTaskId(tapTask.id)} 
                                    />
                                ) : (
                                    <p style={{marginBottom: '15px'}}>Все задания по тапам выполнены!</p>
                                )}

                                {goldenNutTask ? (
                                    <TaskItem 
                                        task={goldenNutTask} 
                                        currentProgress={totalGoldenNutsCaught} 
                                        onClaim={() => onClaim('golden_nut_chain')} 
                                        onShowInfo={() => setInfoTaskId(goldenNutTask.id)} 
                                    />
                                ) : (
                                    <p>Все задания "Охотник за Золотом" выполнены!</p>
                                )}

                                {/* --- ВОТ БЛОК ДЛЯ ТРАНЖИРЫ --- */}
                                {spendTask ? (
                                    <TaskItem 
                                        task={spendTask} 
                                        currentProgress={totalSpent} 
                                        onClaim={() => onClaim('spend_chain')} 
                                        onShowInfo={() => setInfoTaskId(spendTask.id)} 
                                    />
                                ) : (
                                    <p>Все задания "Транжира" выполнены!</p>
                                )}
                                {/* --- КОНЕЦ БЛОКА --- */}
                            </>
                        ); 
                    case 'balance':
                         return balanceTask ? (
                            <TaskItem 
                                task={balanceTask} 
                                currentProgress={balance} 
                                onClaim={() => onClaim('balance_chain')} 
                                onShowInfo={() => setInfoTaskId(balanceTask.id)} 
                            />
                        ) : (
                            <p>Все задания на баланс выполнены!</p>
                        );
                    case 'milestone':
                        return earnedTask ? (
                            <TaskItem 
                                task={earnedTask} 
                                currentProgress={totalEarned} 
                                onClaim={() => onClaim('total_earned_chain')} 
                                onShowInfo={() => setInfoTaskId(earnedTask.id)} 
                            />
                        ) : (
                            <p>Все вехи достигнуты!</p>
                        );
                    default:
                        return null;
                }
            };

            return (
                <div className="modal-overlay" onClick={onClose}>
                    <div className="tasks-modal" onClick={(e) => e.stopPropagation()}>
                        
                        {infoTask ? (
                            <div>
                                <div className="icon level-icon" style={{fontSize: '3em', marginBottom: '15px'}}>{infoTask.icon}</div>
                                <h3 className="max-level">{infoTask.name}</h3>
                                <p style={{fontSize: '1.1em', color: '#eee', lineHeight: 1.4, marginBottom: '20px'}}>
                                    {infoTask.details}
                                </p>
                                <button className="buy-btn" style={{backgroundColor: '#007BFF'}} onClick={() => setInfoTaskId(null)}>
                                    Назад
                                </button>
                            </div>
                        // ИСПРАВЛЕННЫЙ КОД:

                        ) : (
                            <div> {/* <-- ЭТОТ DIV БОЛЬШЕ НЕ ЗАКРЫВАЕТСЯ СРАЗУ ПОСЛЕ TABS */}
                                <h2>Задания</h2>
                                
                                <div className="task-tab-bar">
                                   <div 
                                       className={`task-tab ${activeTaskTab === 'tap' ? 'active' : ''}`}
                                       onClick={() => setActiveTaskTab('tap')}
                                   >
                                       Начало
                                       {(completedTapTasks + completedGoldenNutTasks + completedSpendTasks) > 0 && (
                                           <span className="task-tab-badge">
                                               {completedTapTasks + completedGoldenNutTasks + completedSpendTasks}
                                           </span>
                                       )}
                                   </div>
                                    <div 
                                        className={`task-tab ${activeTaskTab === 'balance' ? 'active' : ''}`}
                                        onClick={() => setActiveTaskTab('balance')}
                                    >
                                        Сбережения
                                        {completedBalanceTasks > 0 && (
                                            <span className="task-tab-badge">{completedBalanceTasks}</span>
                                        )}
                                    </div>
                                    <div 
                                        className={`task-tab ${activeTaskTab === 'milestone' ? 'active' : ''}`}
                                        onClick={() => setActiveTaskTab('milestone')}
                                    >
                                        Прогресс
                                        {completedMilestoneTasks > 0 && (
                                            <span className="task-tab-badge">{completedMilestoneTasks}</span>
                                        )}
                                    </div>
                                </div>
                                
                                <div className="task-list-content">
                                    {renderTabContent()} 
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }
        
        function TaskItem({ task, currentProgress, onClaim, onShowInfo }) { 
            const isComplete = currentProgress >= task.target;
            const progressPercent = Math.min(100, (currentProgress / task.target) * 100);
            
            let rewardText = '...';

            // --- ДОБАВЬ ЭТОТ БЛОК ---
            if (task.type === 'tap' || task.type === 'golden_nut' || task.type === 'spend') {
                rewardText = `+${formatBalance(task.reward)} $NUT`;
            }
            // --- КОНЕЦ БЛОКА ---
                        
            if (task.type === 'balance') rewardText = 'x2';
            if (task.type === 'milestone') rewardText = getMilestoneRewardText(task.reward);

            return (

                <div className={`task-item ${isComplete ? 'is-claimable' : ''}`}>
                    <div className="icon">{task.icon}</div>
                    <div className="task-info">
                        <div className="task-title-row"> 
                            <strong>{task.name}</strong>
                            <button className="task-info-btn" onClick={onShowInfo}>i</button>
                        </div>
                        <div className="progress-text">{`Прогресс: ${formatBalance(currentProgress)} / ${formatBalance(task.target)}`}</div>
                        <div className="progress-bar">
                            <div className="progress-bar-inner" style={{ width: `${progressPercent}%` }}></div>
                        </div>
                    </div>
                    <button 
                        className="buy-btn" 
                        disabled={!isComplete} 
                        onClick={onClaim}
                        style={{marginLeft: '10px'}}
                    >
                        {rewardText}
                    </button>
                </div>
            );
        }

function UpgradeItem({ 
            upgrade, level, cost, canAfford, onBuy, isMaxLevel,
            descriptionLabel, currentValue, nextValue, valueSuffix 
        }) {
            const isPurchased = upgrade.type === 'once' && level > 0;
            
            let buttonText = 'Куплено';
            let buttonClass = 'purchased';
            let isDisabled = true;
            
            if (upgrade.type === 'level') {
                if (isMaxLevel) {
                     buttonText = 'МАКС.';
                     buttonClass = 'max-level'; 
                     isDisabled = true;
                } else {
                     // --- ИСПРАВЛЕНИЕ: Используем formatBalance для сокращения цены ---
                     buttonText = `Ур. ${level + 1} за ${formatBalance(cost)} $NUT`;
                     buttonClass = '';
                     isDisabled = !canAfford;
                }
            } else if (upgrade.type === 'once' && !isPurchased) {
                // --- ИСПРАВЛЕНИЕ: Используем formatBalance для сокращения цены ---
                buttonText = `${formatBalance(cost)} $NUT`;
                buttonClass = '';
                isDisabled = !canAfford;
            }

            // --- ИСПРАВЛЕНИЕ: Делаем formatValue "умнее" ---
            const formatValue = (val) => {
                // 1. Если это уже отформатированная строка (из "Дупла")
                if (typeof val === 'string') {
                    return val; // ...просто возвращаем ее
                }
                // 2. Если это число (из "Бустов")
                if (typeof val === 'number') {
                    // ...форматируем его, как и раньше
                    return val.toFixed(1).replace(/\.0$/, '');
                }
                // 3. На всякий случай
                return val;
            };
            // --- КОНЕЦ ИСПРАВЛЕНИЯ ---
            return (
                <div className="upgrade-item">
                    <img src={upgrade.icon} alt={upgrade.name} />
                    
                    <div className="upgrade-info">
                        <strong style={{color: 'gold'}}>{upgrade.name}</strong>
                        
                        {upgrade.type === 'level' && (
                            <div className="level-text">
                                {isMaxLevel ? `Уровень: ${level} (MAX)` : `Уровень: ${level}`}
                            </div>
                        )}
                        
                        <div className="description-line">
                            
                            {upgrade.type === 'level' && !isMaxLevel && (
                                <span>
                                    {descriptionLabel}
                                    {` +${formatValue(currentValue)} ${valueSuffix}`}
                                    <span className="description-line-next">
                                        {` -> +${formatValue(nextValue)} ${valueSuffix}`}
                                    </span>
                                </span>
                            )}
                            
                            {upgrade.type === 'level' && isMaxLevel && (
                                <span>
                                  {descriptionLabel}
                                  {` +${formatValue(currentValue)} ${valueSuffix}`}
                                </span>
                            )}
                            
                            {upgrade.type === 'once' && (
                                <span>{descriptionLabel}</span>
                            )}
                        </div>
                    </div>
                    
                    <button 
                        className={`buy-btn ${buttonClass}`} 
                        disabled={isDisabled}
                        onClick={onBuy}
                    >
                        {buttonText}
                    </button>
                </div>
            );
        }  


// --- НОВЫЙ КОМПОНЕНТ: Содержимое модального окна "Улучшения" (В СТИЛЕ БУСТОВ) ---
        function DefenseUpgradeView({ levels, balance, onBuy }) {
            
            const formatValueForDisplay = (val) => {
                // Добавим проверку на undefined/null
                if (val === undefined || val === null) return '...';
                return Math.floor(val).toString();
            };

            return (
                <div>
                    <h3 className="home-modal-title">Улучшить Дупло</h3>
                    
                    <div className="upgrade-list" style={{paddingTop: '10px', paddingBottom: '10px'}}>
                        
                        {Object.values(DEFENSE_CATALOG).map(upgrade => {
                            const upgradeId = upgrade.id;
                            
                            // --- !!! ВОТ ОН, ФИКС !!! ---
                            // Если levels[upgradeId] не существует (undefined или 0), 
                            // мы принудительно ставим его на 1, так как 1 - это базовый уровень.
                            const currentLevel = levels[upgradeId] || 1; 
                            // --- КОНЕЦ ФИКСА ---

                            let isMaxLevel = false;
                            let cost = 0;
                            let canAfford = false;
                            let descriptionLabel = "";
                            let currentValue = 0;
                            let nextValue = 0;
                            let valueSuffix = "";

                            // --- НОВАЯ ЛОГИКА ДЛЯ "Укрепить Стенки" (baseHp) ---
                            if (upgradeId === 'baseHp') {
                                isMaxLevel = currentLevel >= MAX_HP_LEVEL;
                                
                                // Добавим проверку, что данные на (currentLevel - 1) существуют
                                const currentLevelData = HP_LEVELS[currentLevel - 1];
                                currentValue = currentLevelData ? currentLevelData.hp : 0; // Безопасное чтение
                                valueSuffix = "HP";
                                descriptionLabel = "Прочность:";

                                if (isMaxLevel) {
                                    canAfford = false;
                                } else {
                                    // Добавим проверку, что данные на (currentLevel) существуют
                                    const nextLevelData = HP_LEVELS[currentLevel];
                                    if (nextLevelData) {
                                        cost = nextLevelData.cost;
                                        canAfford = balance >= cost;
                                        nextValue = nextLevelData.hp;
                                    } else {
                                        // Если данных нет (например, достигли макс. уровня + 1)
                                        isMaxLevel = true; 
                                        canAfford = false;
                                    }
                                }
                            }
                            
                            // --- ЛОГИКА ДЛЯ "Увеличить Сейф" (vault) ---
                            if (upgradeId === 'vault') {
                                isMaxLevel = currentLevel >= MAX_VAULT_LEVEL;
                                
                                // Добавим проверку для vault
                                const currentLevelData = VAULT_LEVELS[currentLevel - 1];
                                currentValue = currentLevelData ? currentLevelData.capacity : 0; // Безопасное чтение
                                valueSuffix = "$NUT Вмест.";
                                descriptionLabel = "Вместимость:";

                                if (isMaxLevel) {
                                    canAfford = false;
                                } else {
                                    // Добавим проверку для vault
                                    const nextLevelData = VAULT_LEVELS[currentLevel];
                                    if (nextLevelData) {
                                        cost = nextLevelData.cost;
                                        canAfford = balance >= cost;
                                        nextValue = nextLevelData.capacity;
                                    } else {
                                        isMaxLevel = true;
                                        canAfford = false;
                                    }
                                }
                            }

                            return (
                                <UpgradeItem 
                                    key={upgradeId}
                                    upgrade={upgrade} 
                                    level={currentLevel}
                                    cost={cost}
                                    canAfford={canAfford}
                                    onBuy={() => onBuy(upgradeId)}
                                    isMaxLevel={isMaxLevel}
                                    descriptionLabel={descriptionLabel}
                                    currentValue={formatValueForDisplay(currentValue)}
                                    nextValue={formatValueForDisplay(nextValue)}
                                    valueSuffix={valueSuffix}
                                />
                            );
                        })}
                        
                    </div>
                </div>
            );
        }
        // --- КОНЕЦ НОВОГО КОМПОНЕНТА ---
            


// --- НОВАЯ ВСПОМОГАТЕЛЬНАЯ ФУНКЦИЯ (Русская версия) ---
        // Конвертирует "10к", "5млн", "2млрд" в числа
        function parseAmountString(str) {
            if (!str) return 0;

            // 1. Убираем пробелы, приводим к нижнему регистру
            let s = str.toLowerCase().trim();
            
            // 2. Заменяем запятую на точку для дробных чисел
            s = s.replace(',', '.');

            let multiplier = 1;
            let numPart = s;

            // 3. Ищем суффиксы в порядке от длинного к короткому
            if (s.endsWith('млрд')) {
                multiplier = 1000000000;
                numPart = s.substring(0, s.length - 4); // убираем "млрд"
            } else if (s.endsWith('млн')) {
                multiplier = 1000000;
                numPart = s.substring(0, s.length - 3); // убираем "млн"
            } else if (s.endsWith('к')) {
                multiplier = 1000;
                numPart = s.substring(0, s.length - 1); // убираем "к"
            }

            // 4. Превращаем оставшуюся часть в число
            const num = parseFloat(numPart);

            // 5. Если это не число (например, "abc"), возвращаем 0
            if (isNaN(num)) {
                return 0;
            }

            // 6. Умножаем число на множитель
            return Math.floor(num * multiplier);
        }
        // --- КОНЕЦ ВСПОМОГАТЕЛЬНОЙ ФУНКЦИИ ---


function VaultControls({ vaultBalance, currentBalance, maxDeposit, onVaultAction }) {
            
            const [amount, setAmount] = useState('');

            // Обработчик для кнопок (Вложить/Забрать)
            const handleAction = (action) => {
                
                // 1. Конвертируем "10к", "5млн" в число
                const numAmount = parseAmountString(amount); // <-- Используем нашу новую функцию

                // 2. Проверка, что введено корректное число
                if (!numAmount || numAmount <= 0) {
                    alert('Введите корректную сумму');
                    setAmount(''); // Сбрасываем некорректный ввод
                    return;
                }
                
                // 3. Вызываем родительский обработчик
                onVaultAction(action, numAmount);
                
                // 4. Очищаем поле после успешного действия
                setAmount('');
            };

            // Обработчик для поля ввода (теперь разрешает русские буквы)
            const handleAmountChange = (e) => {
                const value = e.target.value;
                
                // --- ИЗМЕНЕНИЕ: Разрешаем цифры, точку/запятую и буквы к,м,л,н,р,д ---
                if (/^[\d.,кмлнрд]*$/i.test(value)) { 
                    setAmount(value); // Просто устанавливаем значение
                }
            };
            
            // Проверяем, введено ли число > 0, чтобы активировать кнопки
            // Мы должны проверить это *после* парсинга
            const isAmountEntered = parseAmountString(amount) > 0;
            
            return (
                <div className="vault-controls">
                    
                    {/* Поле для ввода */}
                    <input 
                        type="text"
                        // inputMode="numeric" <-- Убираем, т.к. нам нужна буквенная клавиатура
                        placeholder="Введите сумму (10к, 5млн)" 
                        value={amount}
                        onChange={handleAmountChange} // Наш JS-фильтр
                        style={{
                            width: '90%',
                            padding: '12px',
                            margin: '0 auto 15px auto',
                            display: 'block',
                            borderRadius: '8px',
                            border: '2px solid #a37b4f',
                            background: '#5d4a36',
                            color: 'white',
                            fontSize: '1.1em',
                            textAlign: 'center',
                            boxSizing: 'border-box'
                        }}
                    />

                    {/* 1. Кнопки Вложить/Забрать */}
                    <div className="vault-controls-btn-container">
                        <button 
                            className="buy-btn" 
                            style={{backgroundColor: isAmountEntered ? '#4CAF50' : '#555', color: 'white'}}
                            disabled={!isAmountEntered}
                            onClick={() => handleAction('deposit')}
                        >
                            Вложить
                        </button>
                        <button 
                            className="buy-btn" 
                            style={{backgroundColor: isAmountEntered ? '#E53935' : '#555', color: 'white'}}
                            disabled={!isAmountEntered}
                            onClick={() => handleAction('withdraw')}
                        >
                            Забрать
                        </button>
                    </div>
                    
                    {/* 2. Подпись (теперь показывает баланс) */}
                    <p style={{fontSize: '0.9em', color: '#ccc', margin: '15px 0 0 0', textAlign: 'center'}}>
                        На балансе: {formatBalance(currentBalance)} $NUT
                    </p>
                </div>
            );
        }

// --- НОВЫЙ КОМПОНЕНТ: Карточка Улучшения (Полностью Переписан) ---
function DefenseCard({ upgrade, level, balance, onBuy }) {
    
    // --- ЛОГИКА ДЛЯ УЛУЧШЕНИЯ "Увеличить Сейф" (VAULT) ---
    if (upgrade.id === 'vault') {
        const currentLevel = level; // Текущий уровень (e.g., 1)
        const isMaxLevel = currentLevel >= MAX_VAULT_LEVEL;

        let cost = 0;
        let canAfford = false;
        let buttonText = 'МАКС.';
        let buttonClass = 'max';
        let isDisabled = true;
        let label = `Ур. ${currentLevel}`;
        // Показываем текущую вместимость (Ур 1 -> VAULT_LEVELS[0])
        let effectText = `Вмест: ${formatBalance(VAULT_LEVELS[currentLevel - 1].capacity)}`; 

        if (isMaxLevel) {
            // Уже на макс. уровне, ничего не меняем
        } else {
            // Получаем данные для СЛЕДУЮЩЕГО уровня
            // currentLevel = 1, нужен VAULT_LEVELS[1] (Уровень 2)
            const nextLevelData = VAULT_LEVELS[currentLevel]; 
            
            cost = nextLevelData.cost;
            canAfford = balance >= cost;
            buttonText = `${formatBalance(cost)} $NUT`;
            isDisabled = !canAfford;
            buttonClass = isDisabled ? 'disabled' : '';
            
            // Текст для карточки
            label = `Ур. ${nextLevelData.level}`; // Ур. 2
            effectText = `-> ${formatBalance(nextLevelData.capacity)} Вмест.`; // -> 50K Вмест.
        }

        return (
            <div 
                className={`defense-card ${isDisabled ? 'disabled' : ''}`}
                onClick={!isDisabled ? onBuy : null}
                style={{cursor: !isDisabled ? 'pointer' : 'default'}}
            >
                <div className="defense-card-icon">
                    <img src={upgrade.icon} alt={upgrade.name} /> 
                </div>
                <h5>{upgrade.name}</h5>
                <div className="level">
                    {label} ({effectText}) 
                </div>
                <button 
                    className={`defense-card-cost ${buttonClass}`}
                    disabled={isDisabled}
                >
                    {buttonText}
                </button>
            </div>
        );
    }
    
    // --- СТАРАЯ ЛОГИКА ДЛЯ УЛУЧШЕНИЯ "Укрепить Стенки" (BASEHP) ---
    // (Этот код остался без изменений, он работает как раньше)
    const currentLevel = level;
    const isMaxLevel = false; // У HP нет макс. уровня
    
    const cost = calculateCost(upgrade.baseCost, currentLevel, upgrade.id);
    const canAfford = balance >= cost;
    
    let buttonText = `${formatBalance(cost)} $NUT`;
    let buttonClass = '';
    let isDisabled = !canAfford;

    if (!canAfford) {
        buttonClass = 'disabled';
    }
    
    let label = `Ур. ${currentLevel + 1}`;
    let effectText = `+${calculateBaseHp(currentLevel + 1) - calculateBaseHp(currentLevel)} HP`;

    return (
        <div 
            className={`defense-card ${isDisabled ? 'disabled' : ''}`}
            onClick={!isDisabled ? onBuy : null}
            style={{cursor: !isDisabled ? 'pointer' : 'default'}}
        >
            <div className="defense-card-icon">
                <img src={upgrade.icon} alt={upgrade.name} /> 
            </div>
            <h5>{upgrade.name}</h5>
            <div className="level">
                {label} ({effectText}) 
            </div>
            <button 
                className={`defense-card-cost ${buttonClass}`}
                disabled={isDisabled}
            >
                {buttonText}
            </button>
        </div>
    );
}
// --- КОНЕЦ ЗАМЕНЫ КОМПОНЕНТА ---

// --- НОВЫЙ КОМПОНЕНТ: HP-плашка (HomeHPComponent) ---
function HomeHPComponent({ myBaseHp, style }) { // <-- ТЕПЕРЬ ПРИНИМАЕТ ПРОПС 'style'
    
    // Определяем базовые стили
    const baseStyle = {
        display: 'flex', 
        alignItems: 'center', 
        justifyContent: 'center', 
        zIndex: 5,
    };
    
    // Объединяем базовые стили с переданными стилями (style)
    const finalStyle = {...baseStyle, ...style}; 

    return (
                    <div style={{
                        ...style, 
                        // Мы не используем класс home-hp-display, поэтому стили прямо здесь
                        display: 'flex', 
                        alignItems: 'center', 
                        justifyContent: 'center',
                        color: '#fff', // Белый текст
                        fontSize: '1.4em', // Чуть больше шрифт
                        fontWeight: 'bold', // Жирный шрифт
                        textShadow: '1px 1px 3px rgba(0,0,0,0.7)', // Тень для читаемости
                        backgroundColor: 'transparent', // Прозрачный фон
                        padding: '0', // Нет паддинга
                        borderRadius: '0', // Нет закругления
                        marginTop: '15px' // Оставим отступ сверху
                    }}>
                        <span style={{marginRight: '8px'}}>❤️</span> {/* Красное сердечко */}
                        <span>{myBaseHp.toLocaleString('ru-RU')} HP</span>
                    </div>
                );
            }


// --- НОВЫЙ КОМПОНЕНТ: Наложение HP Дупла ---
function DuploHPOverlay({ myBaseHp }) {
    return (
        <div style={{
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'center', 
            color: '#4CAF50', 
            fontSize: '1.2em', 
            fontWeight: 'bold',
            textShadow: '1px 1px 2px rgba(0, 0, 0, 0.5)',
            
            /* --- ПОДЪЕМ: Используем отрицательный отступ --- */
            marginTop: '-25px', 
            zIndex: 5 /* Убедимся, что находится поверх других элементов */
        }}>
            <img src="images/icon_shield.png" alt="HP" style={{width: '25px', height: '25px', marginRight: '4px'}} /> 
            {formatBalance(myBaseHp)} HP
        </div>
    );
}
        
        // Старт Приложения
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>

</body>
</html>
